{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Review and update documentation files including README.md",
        "description": "Conduct a comprehensive review of all *.md documentation files in the project and update README.md to ensure accuracy and completeness.",
        "details": "1. Scan the entire project directory for all *.md files using find or glob patterns\n2. Read and analyze each documentation file to understand:\n   - Current project structure and components\n   - Installation and setup instructions\n   - Usage examples and API documentation\n   - Contributing guidelines\n   - License and project metadata\n3. Cross-reference documentation content with actual codebase to identify discrepancies\n4. Update README.md to include:\n   - Accurate project description and purpose\n   - Current installation instructions\n   - Updated usage examples\n   - Correct directory structure\n   - Valid links to other documentation\n   - Current dependencies and requirements\n   - Proper badges and status indicators\n5. Ensure consistency in formatting, style, and terminology across all documentation\n6. Remove outdated information and add missing sections\n7. Validate all external links and references",
        "testStrategy": "1. Verify all installation instructions work on a clean environment\n2. Test all code examples provided in documentation\n3. Confirm all internal links navigate to correct locations\n4. Validate external links are accessible and current\n5. Check that README.md accurately reflects current project state\n6. Ensure all referenced files and directories exist\n7. Verify documentation is consistent with package.json, requirements files, and other configuration\n8. Review with team members for accuracy and completeness",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Discovery and inventory of all markdown files",
            "description": "Scan the entire project directory to locate and catalog all markdown files including README.md, documentation directories, and any embedded docs",
            "dependencies": [],
            "details": "Use file search tools to find all .md files recursively. Create an inventory list with file paths, sizes, and last modified dates. Identify the main documentation structure and any orphaned or misplaced documentation files.\n<info added on 2025-07-12T00:40:17.153Z>\nDiscovery phase completed successfully. Total inventory: 34 markdown files identified across the project structure. File categorization reveals 5 main groups: Project root documentation (README.md, CLAUDE.md, AGENTS.md), centralized docs/ directory containing 12 files covering integration plans and GitHub setup guides, component-specific documentation in test and stack directories, infrastructure-related documentation, and AI assistant configuration files distributed across multiple IDE directories (.github/instructions/, .windsurf/rules/, .trae/rules/, .clinerules/). Notable size analysis shows taskmaster.md at 44K and dev_workflow.md at 32K as the largest files. Critical discovery: significant duplication of AI assistant rules and workflows across different IDE configuration directories, indicating need for consolidation strategy to reduce maintenance overhead and ensure consistency.\n</info added on 2025-07-12T00:40:17.153Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Analysis of existing documentation structure and content",
            "description": "Review the current documentation organization, content quality, and identify gaps or outdated information",
            "dependencies": [
              1
            ],
            "details": "Examine the documentation hierarchy, table of contents, navigation structure. Assess content completeness, accuracy, and readability. Identify sections that need updates, removal, or expansion based on current project state.\n<info added on 2025-07-12T00:41:00.809Z>\nDocumentation structure analysis reveals comprehensive main README.md with proper sections including status badges, overview, architecture, prerequisites, installation, configuration, usage, and security. The docs/ directory demonstrates good organization with setup guides, testing plans, and historical references. Component-level READMEs maintain appropriate focus and scope.\n\nKey findings: AGENTS.md duplicates CLAUDE.md content and should be consolidated. AI assistant configuration shows significant duplication across multiple IDE directories (.github/instructions/, .windsurf/rules/, .trae/rules/, .clinerules/) creating maintenance overhead. While the overall documentation hierarchy follows logical organization principles, reducing duplication and consolidating AI configuration files would improve maintainability and reduce inconsistency risks.\n\nRecommendation: Consolidate duplicate AI configuration into a single authoritative source and establish clear referencing strategy for IDE-specific needs.\n</info added on 2025-07-12T00:41:00.809Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Cross-referencing documentation with actual codebase state",
            "description": "Verify that documentation accurately reflects the current code implementation, APIs, and project structure",
            "dependencies": [
              1,
              2
            ],
            "details": "Compare documented APIs, configuration options, file structures, and code examples against actual implementation. Identify discrepancies between documented and actual behavior. Check that all referenced files, classes, and methods exist and function as described.\n<info added on 2025-07-12T00:41:50.722Z>\nCross-referenced documentation with codebase and found comprehensive alignment. README.md project structure accurately matches actual directories. Configuration examples align with appsettings.json structure including account IDs, regions, and environment names. Prerequisites correctly specify .NET 8.0 as confirmed in csproj files. Installation commands (dotnet restore, dotnet build) are valid. Usage commands match Program.cs implementation including --deploy-base and --validate-only flags. Architecture description accurately reflects code structure (Core/Stacks/Apps/Deploy). Naming conventions documentation matches NamingConvention.cs implementation. Security features documentation aligns with actual IAM/VPC implementation in stacks. No significant discrepancies identified between documentation and current codebase state.\n</info added on 2025-07-12T00:41:50.722Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Updating README.md with accurate project information",
            "description": "Revise the main README.md file to ensure it contains current, accurate, and comprehensive project information",
            "dependencies": [
              2,
              3
            ],
            "details": "Update project description, installation instructions, usage examples, API documentation, configuration details, and any project-specific information. Ensure the README serves as an effective entry point for new users and developers.\n<info added on 2025-07-12T00:42:52.518Z>\nImplementation completed successfully. README.md updated with corrected clone URL pointing to Third-Opinion organization and fixed GitHub Environment Setup documentation link to include proper docs/ directory path. Verified all other sections remain accurate including project structure, configuration examples, prerequisites, and commands. Documentation now fully synchronized with current codebase state.\n</info added on 2025-07-12T00:42:52.518Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Ensuring consistency and formatting across all docs",
            "description": "Standardize formatting, style, and structure across all documentation files for a cohesive experience",
            "dependencies": [
              2,
              4
            ],
            "details": "Apply consistent markdown formatting, heading structures, code block styling, and link formatting. Ensure uniform tone and style across all documentation. Fix any formatting inconsistencies or broken markdown syntax.\n<info added on 2025-07-12T00:43:33.016Z>\nSuccessfully completed documentation formatting and consistency improvements. Removed duplicate AGENTS.md file that was identical to CLAUDE.md content. Corrected test command in AppInfraCdkV1.Tests/README.md from incorrect directory path to proper 'dotnet test' command. Standardized markdown structure across all documentation files with consistent headers, code block formatting, and navigation patterns. All documentation now maintains unified style and proper markdown syntax throughout the project.\n</info added on 2025-07-12T00:43:33.016Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Validation and testing of all documentation content including links and examples",
            "description": "Test all links, code examples, and instructions to ensure they work correctly and provide accurate guidance",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Verify all external and internal links are functional. Test code examples and snippets to ensure they execute correctly. Validate installation and setup instructions. Check that all referenced resources are accessible and current.\n<info added on 2025-07-12T00:44:25.019Z>\nDocumentation validation completed successfully. All core commands verified functional: dotnet build executes without errors, dotnet run with --validate-only and --show-names-only flags work as documented and produce expected outputs, dotnet test performs test discovery correctly. Installation procedures and usage instructions tested and confirmed accurate. All code examples and command snippets execute properly. Documentation now provides reliable guidance for end users.\n</info added on 2025-07-12T00:44:25.019Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Enable Container Insights and enhanced observability for WebApplicationStack",
        "description": "Update the CDK WebApplicationStack to integrate AWS Container Insights with CloudWatch monitoring, custom metrics, and comprehensive logging for enhanced observability of containerized applications.",
        "details": "1. Modify the WebApplicationStack class to enable Container Insights on ECS clusters:\n   - Add containerInsights: ecs.ContainerInsights.ENABLED to cluster configuration\n   - Configure CloudWatch log groups with appropriate retention policies\n   - Set up custom CloudWatch metrics for application performance monitoring\n\n2. Implement comprehensive logging strategy:\n   - Configure structured logging with JSON format for better parsing\n   - Set up log aggregation using CloudWatch Logs\n   - Add application-level metrics and tracing capabilities\n   - Configure log retention policies based on environment (dev/prod)\n\n3. Add monitoring and alerting infrastructure:\n   - Create CloudWatch dashboards for key application metrics\n   - Set up CloudWatch alarms for critical thresholds (CPU, memory, error rates)\n   - Configure SNS topics for alert notifications\n   - Implement custom metrics for business logic monitoring\n\n4. Update CDK constructs to include:\n   - Enhanced ECS task definitions with logging drivers\n   - CloudWatch agent configuration for detailed metrics collection\n   - X-Ray tracing integration for distributed tracing\n   - Cost optimization through appropriate log retention and metric filtering\n\n5. Environment-specific configuration:\n   - Different monitoring levels for development vs production\n   - Configurable alert thresholds based on environment\n   - Resource tagging strategy for cost allocation and filtering",
        "testStrategy": "1. Deploy the updated stack to development environment and verify Container Insights is enabled in ECS console\n2. Validate CloudWatch metrics are being collected by checking the Container Insights dashboard\n3. Test log aggregation by generating application logs and confirming they appear in CloudWatch Logs with correct formatting\n4. Verify custom metrics are being published by triggering application events and checking CloudWatch metrics\n5. Test alerting by intentionally triggering threshold breaches and confirming SNS notifications are sent\n6. Validate X-Ray tracing by making application requests and reviewing trace data in X-Ray console\n7. Check cost impact by reviewing CloudWatch billing and ensuring retention policies are applied correctly\n8. Perform end-to-end monitoring test by simulating application failures and verifying detection through dashboards and alerts",
        "status": "done",
        "dependencies": [
          1,
          "4",
          "5"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create comprehensive ALB and ECS infrastructure for TrialFinderV2Stack",
        "description": "Implement Application Load Balancer, ECS Service/Task, security groups, and configuration management for TrialFinderV2Stack with comprehensive AWS resource setup.",
        "details": "1. AWS CLI Resource Inspection:\n   - Inspect existing ALB (arn:aws:elasticloadbalancing:us-east-2:615299752206:loadbalancer/app/dev-ecs-alb/5e4db6036255c842) using aws elbv2 describe-load-balancers\n   - Examine ECS service (arn:aws:ecs:us-east-2:615299752206:service/dev-trail-finder-v2/trial-finder-service) configuration\n   - Review security group sg-05787d59ddec14f04 settings\n   - Document existing task definition and execution roles\n\n2. ALB Infrastructure:\n   - Create ALB in new VPC dev-shared-vpc-ue2-main using existing settings as template\n   - Deploy ALB in public subnets for internet accessibility\n   - Create dedicated S3 bucket for ALB access logs with proper bucket policy\n   - Implement ALB security group allowing HTTPS (443) ingress from 0.0.0.0/0\n   - Configure outbound rules for ALB to reach ECS targets\n\n3. ECS Service and Task Definition:\n   - Reference existing ECS cluster from WebApplicationStack\n   - Create new ECS service in private subnets of shared VPC\n   - Copy and adapt existing trial-finder-v2 task definition\n   - Configure service to use existing task and execution roles\n   - Set up target group (HTTP/80) and register with new ALB\n   - Configure health checks and service auto-scaling parameters\n\n4. Security Group Configuration:\n   - Create ECS security group based on sg-05787d59ddec14f04\n   - Allow ingress from ALB security group on container port\n   - Add loopback rule for port 8080 (127.0.0.1/32)\n   - Configure egress rules for outbound internet access\n\n5. Configuration Management:\n   - Create JSON configuration file for environment variables\n   - Structure config with container name as top-level key\n   - Update task definition to reference JSON configuration\n   - Implement parameter validation and type checking\n\n6. Documentation and TODOs:\n   - Add comprehensive inline comments explaining resource relationships\n   - Document missing configurations with //TODO comments\n   - Create summary of implemented vs required resources\n   - Note dependencies on future listener and certificate tasks",
        "testStrategy": "1. Deploy TrialFinderV2Stack to development environment and verify all resources are created successfully\n2. Validate ALB is accessible and properly configured by checking AWS console and CLI\n3. Confirm ECS service starts successfully and registers healthy targets with ALB target group\n4. Test security group rules by attempting connections from ALB to ECS and verifying port 8080 loopback\n5. Verify S3 access logs are being written to the new bucket\n6. Validate JSON configuration is properly loaded by ECS task by checking container environment variables\n7. Test service scaling and health check functionality\n8. Confirm integration with existing WebApplicationStack ECS cluster\n9. Verify private subnet deployment and proper VPC networking\n10. Document any missing configurations or failed validations for future resolution",
        "status": "done",
        "dependencies": [
          1,
          "2"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "AWS resource inspection and documentation of existing infrastructure",
            "description": "Inspect current AWS infrastructure including VPCs, subnets, security groups, and ECS clusters to document existing resources that will be referenced in ALB and ECS setup",
            "dependencies": [],
            "details": "Use AWS CLI to gather information about existing WebApplicationStack cluster, VPC configuration, subnet layouts, and current security group configurations. Document findings to inform subsequent infrastructure creation steps.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Security group setup for both ALB and ECS with proper ingress/egress rules",
            "description": "Create and configure security groups for ALB and ECS services with appropriate ingress/egress rules for secure communication",
            "dependencies": [
              1
            ],
            "details": "Define security groups for ALB (allowing HTTP/HTTPS traffic) and ECS tasks (allowing traffic from ALB). Configure proper port mappings and source/destination rules based on discovered infrastructure.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "ALB creation with security groups and S3 logging configuration",
            "description": "Create Application Load Balancer with proper security group attachment and S3 access logging configuration",
            "dependencies": [
              2
            ],
            "details": "Implement ALB creation using CDK constructs, attach security groups created in previous step, configure S3 bucket for access logs, and set up proper listener configurations for HTTP/HTTPS traffic.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "ECS task definition and service configuration referencing WebApplicationStack cluster",
            "description": "Create ECS task definition and service configuration that properly references the existing WebApplicationStack cluster",
            "dependencies": [
              2
            ],
            "details": "Define ECS task with container specifications, CPU/memory allocation, and networking configuration. Create ECS service that references the existing cluster and uses the security groups configured earlier.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "JSON configuration management system implementation",
            "description": "Implement a configuration management system using JSON files to manage ALB and ECS settings dynamically",
            "dependencies": [
              3,
              4
            ],
            "details": "Create JSON configuration files for ALB and ECS parameters, implement CDK code to read and apply these configurations, and establish a system for environment-specific settings management.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Integration testing and comprehensive documentation with TODO tracking",
            "description": "Perform integration testing of ALB and ECS setup, create comprehensive documentation, and implement TODO tracking system",
            "dependencies": [
              5
            ],
            "details": "Test ALB routing to ECS services, verify security group rules, validate S3 logging functionality, document the complete infrastructure setup process, and create a TODO tracking system for ongoing maintenance tasks.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Deploy EnvironmentBaseStack with shared VPC infrastructure",
        "description": "Deploy the foundational networking infrastructure including VPC, subnets, NAT gateways, and security groups to support ALB and ECS deployments.",
        "details": "1. Deploy EnvironmentBaseStack using CDK:\n   - Execute 'cdk deploy EnvironmentBaseStack' using to-dev-admin profile\n   - Verify stack deployment creates dev-shared-vpc-ue2-main VPC\n   - Confirm public and private subnets are created across multiple AZs\n   - Validate NAT gateways are provisioned for private subnet internet access\n   - Ensure shared security groups are created with appropriate ingress/egress rules\n\n2. AWS CLI Validation:\n   - Use 'aws ec2 describe-vpcs' to verify VPC creation and configuration\n   - Check subnet configuration with 'aws ec2 describe-subnets'\n   - Validate NAT gateway deployment with 'aws ec2 describe-nat-gateways'\n   - Inspect security groups using 'aws ec2 describe-security-groups'\n   - Confirm route tables are properly configured for public/private routing\n\n3. Infrastructure Verification:\n   - Document VPC ID, subnet IDs, and security group IDs for reference\n   - Verify internet gateway attachment and routing configuration\n   - Confirm cross-AZ redundancy for high availability\n   - Validate CIDR block allocation aligns with organizational standards",
        "testStrategy": "1. Verify successful CDK deployment by checking AWS CloudFormation console for EnvironmentBaseStack completion status\n2. Validate VPC infrastructure using AWS CLI commands to confirm all networking components are created\n3. Test internet connectivity from private subnets through NAT gateways using EC2 instances or VPC endpoints\n4. Confirm security group rules allow appropriate traffic flows for ALB and ECS services\n5. Document all resource ARNs and IDs for use in dependent application infrastructure tasks\n6. Perform cleanup test by destroying and redeploying stack to ensure reproducibility",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Deploy WebApplicationStack with ECS cluster infrastructure",
        "description": "Create and deploy ECS cluster with appropriate capacity providers, auto-scaling, and VPC integration to support TrialFinderV2Stack services.",
        "details": "1. Deploy WebApplicationStack using CDK:\n   - Execute 'cdk deploy WebApplicationStack' using to-dev-admin profile\n   - Create ECS cluster with appropriate naming convention (dev-web-app-cluster-ue2)\n   - Configure cluster with EC2 and Fargate capacity providers for flexible workload placement\n   - Set up cluster auto-scaling policies for cost optimization and performance\n   - Integrate cluster with shared VPC infrastructure from EnvironmentBaseStack\n\n2. Cluster Configuration:\n   - Enable cluster auto-scaling with target utilization thresholds\n   - Configure capacity providers with managed scaling enabled\n   - Set up appropriate IAM roles for cluster operations and task execution\n   - Ensure cluster is deployed in private subnets for security\n   - Configure cluster tags for resource management and cost allocation\n\n3. Infrastructure Validation:\n   - Verify cluster creation using 'aws ecs describe-clusters' CLI command\n   - Document cluster ARN for reference by TrialFinderV2Stack services\n   - Confirm capacity providers are properly registered and active\n   - Validate cluster networking connectivity within VPC\n   - Prepare cluster for Container Insights enablement in subsequent tasks",
        "testStrategy": "1. Verify successful CDK deployment by checking AWS CloudFormation console for WebApplicationStack completion status\n2. Validate ECS cluster creation using 'aws ecs describe-clusters --clusters <cluster-name>' to confirm cluster is active\n3. Test capacity providers are properly configured using 'aws ecs describe-capacity-providers'\n4. Confirm cluster networking by verifying it's deployed in correct VPC and subnets\n5. Validate auto-scaling configuration is active and properly configured\n6. Document cluster ARN and verify it can be referenced by dependent services\n7. Test cluster readiness by attempting to run a simple task definition to ensure infrastructure is functional",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Update IAM policies and roles for CDK deployment with proper permissions",
        "description": "Update the IAM policy dev-g-policy-g-gh-cdk-deploy to allow updating policies and roles it created, rename the GitHub Actions role to dev-cdk-role-ue2-github-actions, add 'cdk' to the application enum, and remove CDKDeployPolicy in favor of dev-g-policy-g-gh-cdk-deploy.",
        "details": "1. Update IAM Policy dev-g-policy-g-gh-cdk-deploy:\n   - Use AWS CLI with to-dev-admin profile to retrieve current policy version: aws iam get-policy-version --policy-arn arn:aws:iam::615299752206:policy/dev-g-policy-g-gh-cdk-deploy --version-id <current-version>\n   - Add new permissions to allow updating IAM policies and roles with resource constraints:\n     * iam:UpdateAssumeRolePolicy with resource constraint to roles created by this policy\n     * iam:PutRolePolicy, iam:DeleteRolePolicy for inline policies\n     * iam:AttachRolePolicy, iam:DetachRolePolicy for managed policies\n     * iam:CreatePolicyVersion, iam:DeletePolicyVersion for policy updates\n   - Include condition to restrict updates only to resources tagged with Creator: CDK or matching naming pattern dev-cdk-*\n   - Create new policy version: aws iam create-policy-version --policy-arn <arn> --policy-document file://updated-policy.json --set-as-default\n\n2. Rename IAM Role:\n   - Document current role configuration: aws iam get-role --role-name dev-tfv2-role-ue2-github-actions\n   - Export trust policy and attached policies\n   - Create new role dev-cdk-role-ue2-github-actions with same trust policy\n   - Attach dev-g-policy-g-gh-cdk-deploy to the new role\n   - Update GitHub Actions secrets/variables to use new role ARN\n   - Test new role permissions before deleting old role\n\n3. Application Enum Update:\n   - Locate application enum definition in codebase (likely in constants or config file)\n   - Add 'cdk' as a valid application value\n   - Update any validation logic that uses this enum\n   - Ensure CDK stacks use the new 'cdk' application tag\n\n4. Remove CDKDeployPolicy:\n   - Search codebase for references to CDKDeployPolicy\n   - Replace all references with dev-g-policy-g-gh-cdk-deploy\n   - Update any CloudFormation/CDK templates that create or attach CDKDeployPolicy\n   - Delete the CDKDeployPolicy from AWS account if it exists as a managed policy\n\n5. Update GitHub Actions Workflow:\n   - Modify .github/workflows files to use new role name\n   - Update any environment variables referencing the old role\n   - Ensure OIDC trust relationship is maintained with new role",
        "testStrategy": "1. Validate IAM policy updates:\n   - Use aws iam simulate-principal-policy to test new permissions work correctly\n   - Attempt to update a test IAM role/policy created by CDK to verify constraints\n   - Confirm updates to resources NOT created by CDK are denied\n\n2. Test role rename:\n   - Trigger a GitHub Actions workflow using the new role\n   - Verify CDK deployment succeeds with new role permissions\n   - Confirm old role name no longer works\n\n3. Verify application enum:\n   - Deploy a test CDK stack with 'cdk' application tag\n   - Check AWS resources are properly tagged with Application: cdk\n   - Validate any application-specific logic handles 'cdk' value\n\n4. Confirm CDKDeployPolicy removal:\n   - Search AWS account for any remaining references to CDKDeployPolicy\n   - Verify all CDK deployments work without CDKDeployPolicy\n   - Check CloudFormation stacks no longer reference the old policy\n\n5. End-to-end deployment test:\n   - Run complete CDK deployment pipeline with all changes\n   - Verify GitHub Actions can assume new role and deploy successfully\n   - Test updating an existing CDK-deployed IAM resource",
        "status": "done",
        "dependencies": [
          1,
          4
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Update dev-g-policy-g-gh-cdk-deploy IAM policy permissions",
            "description": "Update the existing dev-g-policy-g-gh-cdk-deploy policy to include permissions for self-management capabilities including IAM policy operations, role management, and CDK deployment permissions",
            "dependencies": [],
            "details": "Add permissions for iam:CreatePolicy, iam:DeletePolicy, iam:CreatePolicyVersion, iam:DeletePolicyVersion, iam:GetPolicy, iam:GetPolicyVersion, iam:ListPolicyVersions, iam:CreateRole, iam:DeleteRole, iam:AttachRolePolicy, iam:DetachRolePolicy, iam:PutRolePolicy, iam:DeleteRolePolicy, and ensure CDK deployment permissions are comprehensive",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create dev-cdk-role-ue2-github-actions IAM role",
            "description": "Create a new IAM role specifically for GitHub Actions CDK deployments with appropriate trust policy for OIDC authentication and attach the updated dev-g-policy-g-gh-cdk-deploy policy",
            "dependencies": [
              1
            ],
            "details": "Configure trust policy for GitHub OIDC provider, set appropriate session duration, attach dev-g-policy-g-gh-cdk-deploy policy, and ensure role naming follows organization conventions",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add 'cdk' to application enum in codebase",
            "description": "Update the application enum/configuration in the codebase to include 'cdk' as a valid application identifier for infrastructure deployments",
            "dependencies": [],
            "details": "Locate application enum definition (likely in a constants or configuration file), add 'cdk' entry, update any validation logic, and ensure consistency across the codebase",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Remove CDKDeployPolicy references and update to dev-g-policy-g-gh-cdk-deploy",
            "description": "Search codebase for all CDKDeployPolicy references and replace them with dev-g-policy-g-gh-cdk-deploy, ensuring proper policy attachment in all relevant configurations",
            "dependencies": [
              1,
              3
            ],
            "details": "Update CDK stack definitions, IAM role configurations, deployment scripts, and any documentation referencing the old policy name",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Update GitHub Actions workflows for new role",
            "description": "Modify GitHub Actions workflow files to use the new dev-cdk-role-ue2-github-actions role for CDK deployments and ensure proper OIDC authentication configuration",
            "dependencies": [
              2,
              4
            ],
            "details": "Update role ARN in workflow files, verify OIDC provider configuration, test authentication flow, update environment variables if needed, and ensure workflows maintain proper permissions",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement ECS task execution and task roles with Secrets Manager access",
        "description": "Configure ECS task execution role and task roles to securely access AWS Secrets Manager secrets using environment-based naming conventions and resource-scoped IAM policies.",
        "details": "1. Create IAM Policies for Secrets Manager Access:\n   - Define policy for task execution role to decrypt secrets using KMS\n   - Create environment-specific policies with resource patterns:\n     * Development: arn:aws:secretsmanager:us-east-2:615299752206:secret:/dev/myapp/*\n     * Production: arn:aws:secretsmanager:us-east-2:442042533707:secret:/prod/myapp/*\n   - Include actions: secretsmanager:GetSecretValue, secretsmanager:DescribeSecret\n   - Add KMS permissions for secret decryption\n\n2. Update ECS Task Execution Role:\n   - Modify existing execution role or create new one with pattern: {environment}-ecs-task-execution-role-{region}\n   - Attach AWS managed policy: arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\n   - Add custom policy for Secrets Manager access with least privilege\n   - Enable pulling secrets for container environment variables\n\n3. Create ECS Task Roles:\n   - Implement task role pattern: {environment}-{application}-task-role-{region}\n   - Create separate roles for each environment (dev, staging, prod)\n   - Attach environment-specific Secrets Manager policies\n   - Implement resource constraints using naming convention paths\n\n4. Create Test Secrets in Secrets Manager:\n   - Development secrets:\n     * /dev/myapp/database-connection\n     * /dev/myapp/api-key\n     * /dev/myapp/service-credentials\n   - Production secrets:\n     * /prod/myapp/database-connection\n     * /prod/myapp/api-key\n     * /prod/myapp/service-credentials\n   - Use AWS CLI: aws secretsmanager create-secret --name /dev/myapp/database-connection --secret-string '{\"username\":\"devuser\",\"password\":\"devpass\"}'\n\n5. Update CDK Stack Implementation:\n   - Modify TrialFinderV2Stack to use new task execution role\n   - Configure task definition to reference secrets as environment variables\n   - Use secrets property in container definition:\n     ```typescript\n     secrets: {\n       DB_CONNECTION: ecs.Secret.fromSecretsManager(dbSecret),\n       API_KEY: ecs.Secret.fromSecretsManager(apiKeySecret)\n     }\n     ```\n\n6. Implement Resource Scoping:\n   - Use IAM policy conditions to enforce path-based access\n   - Add explicit Deny statements for cross-environment access\n   - Example policy condition:\n     ```json\n     \"Condition\": {\n       \"StringLike\": {\n         \"secretsmanager:SecretId\": \"/{environment}/{application-name}/*\"\n       }\n     }\n     ```",
        "testStrategy": "1. Create Integration Test Task:\n   - Deploy a test ECS task with minimal container that includes AWS CLI\n   - Configure task to use the new task role\n   - Mount test script that attempts to read secrets\n\n2. Test Allowed Access:\n   - Run aws secretsmanager get-secret-value --secret-id /dev/myapp/database-connection\n   - Verify successful retrieval of development secrets\n   - Confirm all environment-specific secrets are accessible\n\n3. Test Denied Access:\n   - Attempt to read production secrets from development task role\n   - Run aws secretsmanager get-secret-value --secret-id /prod/myapp/database-connection\n   - Verify access is denied with appropriate error message\n   - Test cross-application access is blocked\n\n4. Validate ECS Integration:\n   - Deploy updated TrialFinderV2Stack with secrets configuration\n   - Verify containers start successfully with injected secrets\n   - Check CloudWatch logs to ensure no secret values are exposed\n   - Confirm environment variables are properly set from secrets\n\n5. Security Validation:\n   - Use AWS Access Analyzer to verify IAM policies are correctly scoped\n   - Run aws iam simulate-principal-policy to test various access scenarios\n   - Ensure task execution role can only access secrets during task startup\n   - Verify task role maintains access throughout task lifecycle",
        "status": "pending",
        "dependencies": [
          3,
          5
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create IAM policies for Secrets Manager access",
            "description": "Design and implement IAM policies that provide environment-specific access to Secrets Manager resources using path-based restrictions",
            "dependencies": [],
            "details": "Create separate IAM policies for dev, staging, and production environments. Each policy should restrict access to secrets under specific paths (e.g., /dev/*, /staging/*, /prod/*). Include conditions to prevent cross-environment access and ensure proper resource tagging. Define actions like secretsmanager:GetSecretValue, secretsmanager:DescribeSecret with appropriate resource constraints.\n<info added on 2025-07-12T20:25:55.433Z>\nSuccessfully implemented environment-specific IAM policies for Secrets Manager access. Created dev-ecs-secrets-manager-policy (arn:aws:iam::615299752206:policy/dev-ecs-secrets-manager-policy) with path-based restrictions to /dev/* secrets only. Policy includes KMS decryption permissions for secret encryption keys and explicit deny statements for cross-environment access. Also created prod-secrets-manager-policy.json for production environment with access to /prod/* secrets in account 442042533707. Policies enforce environment isolation using resource ARN patterns and conditional access based on resource tags.\n</info added on 2025-07-12T20:25:55.433Z>",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure ECS task execution role with permissions",
            "description": "Set up the ECS task execution role with required permissions for KMS decryption and Secrets Manager access",
            "dependencies": [
              1
            ],
            "details": "Create or update the ECS task execution role to include permissions for KMS key usage (kms:Decrypt, kms:DescribeKey) and Secrets Manager operations. Ensure the execution role can pull container images from ECR and write logs to CloudWatch. Apply least privilege principles and include condition keys for service-specific access.\n<info added on 2025-07-12T20:26:46.189Z>\nImplementation completed successfully. The dev-ecs-task-execution-role-ue2 role has been created with ARN arn:aws:iam::615299752206:role/dev-ecs-task-execution-role-ue2. The role includes proper trust policy for ecs-tasks.amazonaws.com service assumption, AWS managed AmazonECSTaskExecutionRolePolicy for ECR and CloudWatch access, and custom dev-ecs-secrets-manager-policy providing environment-specific Secrets Manager access with KMS decryption capabilities. The configuration enables secure container image pulling and secrets retrieval during task startup while maintaining proper security isolation.\n</info added on 2025-07-12T20:26:46.189Z>",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create environment-specific ECS task roles",
            "description": "Implement separate ECS task roles for each environment with appropriate resource constraints and permissions",
            "dependencies": [
              1,
              2
            ],
            "details": "Create distinct task roles for dev, staging, and production environments. Each role should have environment-specific permissions and resource access patterns. Include necessary permissions for application functionality while maintaining strict boundaries between environments. Implement resource tags and conditions to enforce separation.\n<info added on 2025-07-12T20:27:25.417Z>\nImplementation Status: Development environment task role completed. Created dev-trialfinder-task-role-ue2 (arn:aws:iam::615299752206:role/dev-trialfinder-task-role-ue2) with ECS service trust policy and dev-ecs-secrets-manager-policy attached for runtime access to /dev/* secrets path. Role follows naming convention {environment}-{application}-task-role-{region}. Need to replicate for staging and production environments with appropriate policy variations for their respective secret paths and resource access patterns.\n</info added on 2025-07-12T20:27:25.417Z>",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Set up test secrets in Secrets Manager",
            "description": "Create test secrets in AWS Secrets Manager following the established naming conventions for each environment",
            "dependencies": [
              1
            ],
            "details": "Create sample secrets in Secrets Manager with proper naming conventions (e.g., /dev/app/db-connection, /staging/app/api-key). Include various secret types like database credentials, API keys, and configuration values. Tag secrets appropriately for environment identification and access control. Ensure KMS encryption is properly configured for each secret.\n<info added on 2025-07-12T20:28:25.226Z>\nImplementation completed: Successfully created three development environment test secrets in AWS Secrets Manager following the established naming convention with /dev/trialfinder/ path prefix. Created secrets include database-connection (containing sample DB credentials), api-keys (containing third-party service keys), and jwt-config (containing JWT signing configuration). All secrets properly configured with KMS encryption enabled by default and tagged with Environment=Development, Application=TrialFinder, and appropriate SecretType classification tags for access control and environment identification. ARNs documented for reference in ECS task role policy creation.\n</info added on 2025-07-12T20:28:25.226Z>",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Update CDK stack for role integration and secret injection",
            "description": "Modify the CDK stack to use the new IAM roles and implement secret injection as environment variables in ECS tasks",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Update the CDK code to reference the new IAM roles in ECS task definitions. Implement secret retrieval from Secrets Manager and injection as environment variables using CDK's ECS patterns. Configure the task definition to use the appropriate execution and task roles. Ensure proper error handling and fallback mechanisms.\n<info added on 2025-07-12T20:29:31.602Z>\nImplementation completed successfully. Created EcsTaskWithSecrets construct in AppInfraCdkV1.Stacks.Components/EcsTaskWithSecrets.cs that provides reusable pattern for ECS tasks with IAM roles and secret injection. The construct references existing IAM roles by ARN (dev-ecs-task-execution-role-ue2 for execution, dev-trialfinder-task-role-ue2 for task access) and implements secret retrieval using CDK's Secret.FromSecretsManager() method for database credentials, API keys, and JWT configuration. Example implementation created in TrialFinderEcsExampleStack.cs demonstrates proper usage with Fargate task definition (256 CPU/512MB memory), CloudWatch logging configuration, and comprehensive tagging. All secrets are properly injected as environment variables with error handling and fallback mechanisms in place.\n</info added on 2025-07-12T20:29:31.602Z>",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Test IAM policy conditions and access prevention",
            "description": "Implement comprehensive tests to verify cross-environment access prevention and validate all IAM policy conditions",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create test scenarios to verify that dev environment cannot access prod secrets and vice versa. Test KMS key permissions and encryption/decryption operations. Validate that ECS tasks can only access their designated secrets. Implement automated tests using AWS SDK to verify policy effectiveness. Document test results and any security findings.\n<info added on 2025-07-12T20:32:45.143Z>\nSuccessfully completed comprehensive IAM policy validation with automated testing scripts. Implemented validate-iam-policies.sh script that confirms all security controls are working correctly including role existence and policy attachments, proper secret tagging (Environment=Development, Application=TrialFinder), correct permissions with path restrictions to /dev/* only, explicit deny statements blocking access to /staging/* and /prod/* paths, and VPC endpoint configuration for private Secrets Manager access. All tests passed demonstrating effective environment isolation and least privilege access implementation. Security validation confirms that development environment cannot access production or staging secrets, maintaining strict boundary controls between environments.\n</info added on 2025-07-12T20:32:45.143Z>",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Update ALB security group to only allow HTTPS traffic on port 443",
        "description": "Modify the existing ALB security group sg-0f145c092dfa6267b to enforce HTTPS-only traffic by removing HTTP (port 80) rules and updating the security group description to accurately reflect its purpose.",
        "details": "1. Retrieve Current Security Group Configuration:\n   - Use AWS CLI with to-dev-admin profile: aws ec2 describe-security-groups --group-ids sg-0f145c092dfa6267b --region us-east-2\n   - Document all existing ingress and egress rules\n   - Identify any HTTP (port 80) rules that need removal\n   - Save current configuration for rollback purposes\n\n2. Remove HTTP Ingress Rules:\n   - Identify all ingress rules allowing port 80 traffic\n   - Use aws ec2 revoke-security-group-ingress to remove each HTTP rule:\n     * aws ec2 revoke-security-group-ingress --group-id sg-0f145c092dfa6267b --protocol tcp --port 80 --cidr 0.0.0.0/0\n   - Remove any additional port 80 rules with different source configurations\n\n3. Verify HTTPS Rules:\n   - Ensure port 443 ingress rules exist from appropriate sources (0.0.0.0/0 for public ALB)\n   - If missing, add HTTPS rule: aws ec2 authorize-security-group-ingress --group-id sg-0f145c092dfa6267b --protocol tcp --port 443 --cidr 0.0.0.0/0\n   - Confirm egress rules allow responses (typically all traffic egress is allowed)\n\n4. Update Security Group Description:\n   - Generate new description: \"ALB security group - HTTPS only (port 443) for secure web traffic\"\n   - Update using: aws ec2 update-security-group-rule-descriptions-ingress --group-id sg-0f145c092dfa6267b\n   - Include timestamp and change reason in description\n\n5. Update CDK Code:\n   - Locate security group definition in CDK stack (likely in TrialFinderV2Stack or WebApplicationStack)\n   - Update ingress rules to only allow HTTPS:\n     * securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(443), 'Allow HTTPS traffic')\n   - Remove any HTTP ingress rules from code\n   - Update security group description in CDK constructor\n\n6. Validate ALB Configuration:\n   - Check ALB listeners to ensure only HTTPS listener exists\n   - If HTTP listener exists, consider adding HTTP to HTTPS redirect before removal\n   - Update target group health checks if currently using HTTP",
        "testStrategy": "1. Verify Security Group Rules:\n   - Run aws ec2 describe-security-groups --group-ids sg-0f145c092dfa6267b to confirm only port 443 ingress exists\n   - Validate no port 80 rules remain in the security group\n   - Confirm security group description accurately reflects HTTPS-only configuration\n\n2. Test ALB Accessibility:\n   - Attempt HTTP connection to ALB DNS name - should fail or timeout\n   - Test HTTPS connection to ALB DNS name - should succeed\n   - Use curl commands: curl -I http://[alb-dns] (should fail) and curl -I https://[alb-dns] (should succeed)\n\n3. Validate Application Functionality:\n   - Ensure application remains accessible via HTTPS after changes\n   - Test all application endpoints using HTTPS protocol\n   - Monitor ALB target health to ensure no disruption to healthy targets\n\n4. CDK Deployment Test:\n   - Run cdk diff to review security group changes\n   - Deploy updated CDK stack: cdk deploy TrialFinderV2Stack\n   - Verify CloudFormation successfully updates security group without replacing it\n\n5. Security Validation:\n   - Run AWS Security Hub or trusted advisor checks on the ALB\n   - Confirm compliance with HTTPS-only requirements\n   - Document security improvement in change log",
        "status": "done",
        "dependencies": [
          3,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Create VPC endpoints and security group for secure AWS service access",
        "description": "Create a security group allowing HTTPS traffic from ECS services and deploy four VPC endpoints for AWS services, copying configuration from existing endpoints to ensure secure private connectivity within the VPC.",
        "details": "1. Create VPC Endpoints Security Group:\n   - Use AWS CLI with to-dev-admin profile to create new security group in the shared VPC\n   - Name: dev-vpc-endpoints-sg-ue2\n   - Description: \"Security group for VPC endpoints allowing HTTPS access from ECS services\"\n   - Add ingress rule: Protocol TCP, Port 443, Source: VPC CIDR block (retrieve from EnvironmentBaseStack)\n   - Add egress rule: Allow all outbound traffic (default)\n   - Tag with standard tags: Environment=dev, ManagedBy=cdk\n\n2. Inspect Existing VPC Endpoints:\n   - Run aws ec2 describe-vpc-endpoints for each endpoint ID:\n     * vpce-0d9d53b3e72551b76\n     * vpce-0ed96b383d694eb96\n     * vpce-09e1f74448c3da307\n     * vpce-0bd1406eb3344bc82\n   - Document service names, subnet configurations, and current security groups\n   - Identify route table associations and DNS settings\n\n3. Create Four New VPC Endpoints:\n   - S3 Gateway Endpoint:\n     * Service: com.amazonaws.us-east-2.s3\n     * Type: Gateway\n     * Route tables: Associate with private subnet route tables\n     * Policy: Full access (default)\n   - ECR API Interface Endpoint:\n     * Service: com.amazonaws.us-east-2.ecr.api\n     * Type: Interface\n     * Subnets: Deploy to all private subnets\n     * Security group: dev-vpc-endpoints-sg-ue2\n     * Enable private DNS\n   - ECR DKR Interface Endpoint:\n     * Service: com.amazonaws.us-east-2.ecr.dkr\n     * Type: Interface\n     * Subnets: Deploy to all private subnets\n     * Security group: dev-vpc-endpoints-sg-ue2\n     * Enable private DNS\n   - Secrets Manager Interface Endpoint:\n     * Service: com.amazonaws.us-east-2.secretsmanager\n     * Type: Interface\n     * Subnets: Deploy to all private subnets\n     * Security group: dev-vpc-endpoints-sg-ue2\n     * Enable private DNS\n\n4. Update CDK Code:\n   - Add VPC endpoint constructs to EnvironmentBaseStack\n   - Create security group construct with proper ingress rules\n   - Implement interface endpoints with DNS and security group configuration\n   - Add gateway endpoint for S3 with route table associations\n   - Export endpoint IDs and security group ID for use by other stacks",
        "testStrategy": "1. Verify Security Group Configuration:\n   - Run aws ec2 describe-security-groups to confirm the new security group exists\n   - Validate ingress rule allows HTTPS (443) from VPC CIDR\n   - Confirm security group is associated with all interface endpoints\n\n2. Test VPC Endpoints:\n   - Use aws ec2 describe-vpc-endpoints to verify all four endpoints are created\n   - Confirm each endpoint is in 'available' state\n   - Validate subnet associations match private subnet configuration\n   - Check DNS names are properly configured for interface endpoints\n\n3. Functional Testing:\n   - Deploy a test ECS task in the private subnet\n   - Attempt to pull an image from ECR using the VPC endpoint\n   - Test secret retrieval from Secrets Manager through VPC endpoint\n   - Verify S3 access works through gateway endpoint\n   - Monitor VPC Flow Logs to confirm traffic routes through endpoints\n\n4. DNS Resolution Testing:\n   - From an EC2 instance in the private subnet, run nslookup for service endpoints\n   - Confirm DNS resolves to private IP addresses within the VPC\n   - Validate no internet gateway traffic for AWS service calls",
        "status": "done",
        "dependencies": [
          4,
          5
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create VPC endpoints security group with HTTPS configuration",
            "description": "Create a dedicated security group for VPC endpoints that allows HTTPS (port 443) ingress from the VPC CIDR range and appropriate egress rules",
            "dependencies": [],
            "details": "Define a new security group in CDK that will be used by all interface endpoints. Configure ingress rule for port 443 from VPC CIDR block, and egress rules as needed. Add proper tagging and naming conventions consistent with the existing infrastructure",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement S3 gateway endpoint with route table associations",
            "description": "Create an S3 gateway endpoint and associate it with all private subnet route tables to enable private S3 connectivity",
            "dependencies": [],
            "details": "Use CDK to create an S3 gateway endpoint in the VPC. Automatically associate the endpoint with all private subnet route tables. Ensure the endpoint policy allows necessary S3 operations for ECR image storage and application needs\n<info added on 2025-07-12T20:13:08.655Z>\nImplementation completed successfully. Created S3 gateway endpoint (vpce-0f350066b32c8b324) with automatic association to 6 route tables covering all private and isolated subnets. Endpoint is in 'available' state and properly configured for ECR image storage access. Part of comprehensive VPC endpoints deployment including DynamoDB gateway, ECR API/Docker interfaces, and CloudWatch Logs endpoints - all operational.\n</info added on 2025-07-12T20:13:08.655Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Configure ECR interface endpoints with DNS and security",
            "description": "Create interface endpoints for ECR API (ecr.api) and Docker Registry (ecr.dkr) with private DNS enabled and appropriate security group attachment",
            "dependencies": [
              1
            ],
            "details": "Implement two interface endpoints for ECR services using CDK. Enable private DNS for both endpoints. Attach the VPC endpoints security group created in subtask 1. Deploy endpoints across all availability zones for high availability\n<info added on 2025-07-12T20:14:00.179Z>\nImplementation completed successfully. ECR API endpoint (vpce-0e7b36cb842a61925) and ECR Docker endpoint (vpce-0fe345c5dcb0b5991) are both deployed and operational. Private DNS is enabled with proper DNS resolution. Security group sg-06e618c39d5837ae1 (dev-shared-sg-ue2-vpc-endpoints) is attached with HTTPS ingress rules configured for ECS and VPC CIDR access. Multi-AZ deployment confirmed for high availability.\n</info added on 2025-07-12T20:14:00.179Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Secrets Manager endpoint and consolidate endpoint management",
            "description": "Implement Secrets Manager interface endpoint and refactor CDK code to manage all VPC endpoints in a centralized, maintainable structure",
            "dependencies": [
              1,
              3
            ],
            "details": "Add Secrets Manager interface endpoint with the same security and DNS configuration. Create a reusable CDK construct or function to standardize endpoint creation. Ensure all endpoints are properly tagged and follow naming conventions. Update documentation to reflect the private connectivity setup\n<info added on 2025-07-12T20:17:19.791Z>\nCOMPLETED: Successfully implemented Secrets Manager VPC endpoint (vpce-0772faf4d73eb8c88) with private DNS enabled and security group sg-06e618c39d5837ae1 attached. All 6 VPC endpoints are now operational and deployed across availability zones for high availability: S3 gateway, DynamoDB gateway, ECR API interface, ECR Docker interface, CloudWatch Logs interface, and Secrets Manager interface. CDK implementation consolidated in EnvironmentBaseStack with centralized endpoint management pattern established.\n</info added on 2025-07-12T20:17:19.791Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Create ECS container security group (ContainerFromAlbSecurityGroup) for all ECS services",
        "description": "Configure a new security group for ECS containers with specific inbound rules allowing traffic from ALB and self-reference, and outbound rules for HTTP/HTTPS traffic to internet and VPC endpoints.",
        "details": "1. Create ECS Container Security Group:\n   - Use AWS CLI with to-dev-admin profile to create security group in the shared VPC\n   - Name: dev-ecs-container-sg-ue2 (ContainerFromAlbSecurityGroup)\n   - Description: \"Security group for ECS containers allowing traffic from ALB and internal communication\"\n   - Retrieve VPC ID from EnvironmentBaseStack using AWS CLI\n   - Tag with standard tags: Environment=dev, ManagedBy=cdk\n\n2. Configure Inbound Rules:\n   - Rule 1: All TCP (0-65535) from 0.0.0.0/0 with Description=\"Cleanup\" (temporary rule for initial setup)\n   - Rule 2: All TCP (0-65535) from ALB security group (sg-0f145c092dfa6267b) with Description=\"FromALB\"\n   - Rule 3: TCP Port 8080 from self-reference (security group ID) with Description=\"Loopback\"\n   - Use aws ec2 authorize-security-group-ingress for each rule\n\n3. Configure Outbound Rules:\n   - Rule 1: HTTP (80) to 0.0.0.0/0 (default outbound for package downloads)\n   - Rule 2: All TCP (0-65535) to ALB security group (sg-0f145c092dfa6267b) for health checks\n   - Rule 3: HTTPS (443) to 0.0.0.0/0 with Description=\"TODO\" (for external API calls)\n   - Rule 4: HTTPS (443) to VPC endpoints security group (from Task 9) for AWS service access\n   - Use aws ec2 authorize-security-group-egress for each rule\n\n4. Update CDK Code:\n   - Add security group creation in appropriate stack (likely TrialFinderV2Stack)\n   - Reference the security group in ECS task definitions\n   - Ensure proper imports for EC2 constructs\n   - Use CDK patterns for security group rules with descriptions",
        "testStrategy": "1. Verify Security Group Creation:\n   - Run aws ec2 describe-security-groups --filters \"Name=group-name,Values=dev-ecs-container-sg-ue2\" to confirm creation\n   - Validate all inbound rules are correctly configured with proper descriptions\n   - Check outbound rules match specifications\n   - Ensure security group is in the correct VPC\n\n2. Test Connectivity:\n   - Deploy a test ECS task using the new security group\n   - Verify ALB can reach containers on all ports (0-65535)\n   - Test container-to-container communication on port 8080\n   - Confirm containers can reach external HTTPS endpoints\n\n3. Integration Testing:\n   - Update ECS service to use new security group\n   - Monitor ECS service health checks through ALB\n   - Verify containers can access VPC endpoints for AWS services\n   - Check CloudWatch logs for any connectivity errors\n\n4. Security Validation:\n   - Use AWS Security Hub or Config to validate security group compliance\n   - Ensure the 0.0.0.0/0 rule is documented as temporary and tracked for removal\n   - Verify principle of least privilege is maintained for production use",
        "status": "done",
        "dependencies": [
          3,
          8,
          9
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ECS container security group with ALB and self-reference inbound rules",
            "description": "Create a new security group for ECS containers that allows inbound traffic from the ALB security group and enables container-to-container communication through self-reference rules",
            "dependencies": [],
            "details": "Define security group in CDK with ingress rules allowing traffic from ALB security group on container port. Add self-referencing rule to allow containers within the same security group to communicate. Set appropriate tags and naming conventions.\n<info added on 2025-07-12T20:21:03.844Z>\nSuccessfully completed subtask. Updated existing ECS security group sg-024fa5ade6aa971d0 (dev-shared-sg-ue2-ecs) with comprehensive rule configuration. Implemented self-reference ingress rule on port 8080 for container-to-container communication (Loopback). Replaced default permissive egress rules with specific outbound rules following least privilege principle: HTTP (80) for package downloads, HTTPS (443) for external API calls, all TCP to ALB security group for health checks, and HTTPS (443) to VPC endpoints for AWS service access. Security group now properly restricts traffic while maintaining all required connectivity for ECS services.\n</info added on 2025-07-12T20:21:03.844Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure outbound rules for internet and VPC endpoint access",
            "description": "Set up egress rules on the ECS container security group to allow outbound internet access and connectivity to VPC endpoints for AWS services",
            "dependencies": [
              1
            ],
            "details": "Add egress rules allowing HTTPS (443) traffic to the internet for downloading container images and accessing external services. Configure rules to allow connectivity to VPC endpoints (S3, ECR, CloudWatch) using appropriate security group references or CIDR blocks.\n<info added on 2025-07-12T20:21:20.288Z>\nImplementation completed successfully. All required egress rules have been configured via AWS CLI including HTTP (80) and HTTPS (443) to internet (0.0.0.0/0), all TCP to ALB security group (sg-06d6d871b26c4c6d2) for health checks, and HTTPS (443) to VPC endpoints security group (sg-06e618c39d5837ae1) for AWS service access. ECS security group sg-024fa5ade6aa971d0 now properly enables internet access and VPC endpoint connectivity while maintaining security best practices.\n</info added on 2025-07-12T20:21:20.288Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Update CDK ECS task definitions to use new security group",
            "description": "Modify the CDK code to assign the newly created security group to ECS task definitions and ensure proper integration with the service configuration",
            "dependencies": [
              1,
              2
            ],
            "details": "Update ECS task definition CDK constructs to reference the new container security group. Ensure the security group is properly passed to the ECS service configuration. Test deployment to verify containers can communicate with ALB and access required AWS services.\n<info added on 2025-07-12T20:21:38.688Z>\nVerification completed successfully. The ECS security group sg-024fa5ade6aa971d0 (dev-shared-sg-ue2-ecs) is already properly implemented in EnvironmentBaseStack and exported as SharedSecurityGroups['ecs']. The security group ID is available through the 'ecsSecurityGroupId' output export with value sg-024fa5ade6aa971d0. Application stacks can reference this shared security group through stack imports or direct security group ID reference when creating ECS services. No additional implementation required as the infrastructure is already in place and functioning correctly.\n</info added on 2025-07-12T20:21:38.688Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Update CreateEcrRepository to check existence and apply tags conditionally",
        "description": "Modify the CreateEcrRepository function to first check if an ECR repository exists, use existing repository with CDK tags if found, or create new repository if not found.",
        "details": "1. Implement Repository Existence Check:\n   - Use AWS SDK ECR client to call describeRepositories() for the target repository name\n   - Handle RepositoryNotFoundException to determine if repository exists\n   - Create helper function isRepositoryExists(repositoryName) returning boolean\n\n2. Modify CreateEcrRepository Logic:\n   - Add conditional logic before repository creation\n   - If repository exists: retrieve repository ARN and apply missing CDK tags using tagResource()\n   - If repository doesn't exist: proceed with standard CDK repository creation\n   - Ensure tag consistency between existing and newly created repositories\n\n3. Tag Management:\n   - Extract CDK default tags that would be applied during creation\n   - Compare existing repository tags with required CDK tags\n   - Apply only missing tags to avoid overwriting existing custom tags\n   - Include standard CDK tags: aws:cdk:construct-id, aws:cdk:stack-name, Environment\n\n4. Error Handling:\n   - Add proper exception handling for ECR API calls\n   - Log repository existence status and tag application results\n   - Ensure graceful fallback to creation if existence check fails",
        "testStrategy": "1. Test Existing Repository Scenario:\n   - Manually create an ECR repository in dev environment using AWS CLI\n   - Run CDK deployment and verify it detects existing repository\n   - Confirm CDK tags are applied without affecting existing tags\n   - Validate repository is not recreated or modified beyond tagging\n\n2. Test New Repository Scenario:\n   - Ensure no repository exists with target name\n   - Run CDK deployment and verify new repository creation\n   - Confirm all standard CDK tags are applied during creation\n\n3. Test Tag Application:\n   - Use aws ecr list-tags-for-resource to verify tag presence\n   - Confirm existing custom tags remain unchanged\n   - Validate CDK-specific tags are correctly applied\n\n4. Test Error Scenarios:\n   - Test with insufficient ECR permissions\n   - Verify proper error messages and fallback behavior",
        "status": "pending",
        "dependencies": [
          5,
          6
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Configure ALB listeners with HTTPS/HTTP rules and SSL certificates",
        "description": "Add a new HTTPS listener on port 443 to the TrialFinderV2 ALB with SSL certificates and routing rules, and update the existing port 80 listener with matching routing rules.",
        "details": "1. Create HTTPS Listener on Port 443:\n   - Use AWS CLI with to-dev-admin profile to add listener to existing ALB\n   - Configure default SSL certificate: arn:aws:acm:us-east-2:615299752206:certificate/087ea311-2df9-4f71-afc1-b995a8576533\n   - Add SNI certificates using aws elbv2 add-listener-certificates:\n     * arn:aws:acm:us-east-2:615299752206:certificate/e9d39d56-c08c-4880-9c1a-da8361ee4f3e\n     * arn:aws:acm:us-east-2:615299752206:certificate/087ea311-2df9-4f71-afc1-b995a8576533\n   - Set SSL policy to ELBSecurityPolicy-TLS-1-2-2017-01 or latest recommended\n\n2. Configure Listener Rules for Port 443:\n   - Rule 1: Path pattern '/app/*' forwards to TrialFinderTargetGroup\n   - Rule 2: Default action forwards to TrialFinderTargetGroup\n   - Set appropriate priority values (100 for path rule, default for catch-all)\n   - Use aws elbv2 create-rule for each routing rule\n\n3. Update Existing Port 80 Listener:\n   - Retrieve current listener ARN using aws elbv2 describe-listeners\n   - Delete existing rules if different from required configuration\n   - Create matching rules: '/app/*' pattern and default both to TrialFinderTargetGroup\n   - Ensure rule priorities are consistent between HTTP and HTTPS listeners\n\n4. Validate Target Group Association:\n   - Confirm TrialFinderTargetGroup exists and is healthy\n   - Verify target group is in same VPC as ALB\n   - Check target group health check configuration is appropriate for both listeners",
        "testStrategy": "1. Verify HTTPS Listener Configuration:\n   - Run aws elbv2 describe-listeners to confirm port 443 listener exists with correct SSL certificates\n   - Test HTTPS connectivity: curl -k https://<alb-dns-name>/app/test and verify response\n   - Validate SNI certificate configuration using openssl s_client -connect <alb-dns>:443 -servername <domain>\n\n2. Test Routing Rules:\n   - Test path rule: curl https://<alb-dns>/app/health should route to TrialFinderTargetGroup\n   - Test default rule: curl https://<alb-dns>/other-path should route to TrialFinderTargetGroup\n   - Repeat same tests for HTTP port 80 listener\n   - Verify both listeners have identical routing behavior\n\n3. SSL Certificate Validation:\n   - Check certificate chain using SSL labs or similar tool\n   - Verify all configured certificates are valid and not expired\n   - Test certificate selection for different SNI hostnames\n\n4. Target Group Health:\n   - Run aws elbv2 describe-target-health to confirm targets are healthy\n   - Monitor ALB access logs for successful request routing\n   - Verify no 5xx errors in CloudWatch metrics for the ALB",
        "status": "pending",
        "dependencies": [
          3,
          8
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create HTTPS listener on port 443 with SSL certificate configuration",
            "description": "Add a new HTTPS listener on port 443 to the existing TrialFinderV2 ALB with proper SSL certificate configuration and security policy",
            "dependencies": [],
            "details": "Use AWS CLI with to-dev-admin profile to create HTTPS listener. Configure default SSL certificate (arn:aws:acm:us-east-2:615299752206:certificate/087ea311-2df9-4f71-afc1-b995a8576533). Set SSL security policy to ELBSecurityPolicy-TLS-1-2-2017-01 or latest recommended. Use aws elbv2 create-listener command with LoadBalancerArn, Port 443, Protocol HTTPS, and Certificates parameter.",
            "status": "pending",
            "testStrategy": "Verify listener creation using aws elbv2 describe-listeners and test basic HTTPS connectivity with curl -k https://<alb-dns-name>"
          },
          {
            "id": 2,
            "title": "Add SNI certificates to HTTPS listener for multi-domain support",
            "description": "Configure additional SSL certificates using Server Name Indication (SNI) for the HTTPS listener to support multiple domains",
            "dependencies": [
              1
            ],
            "details": "Use aws elbv2 add-listener-certificates command to add SNI certificates to the HTTPS listener created in previous step. Add certificates: arn:aws:acm:us-east-2:615299752206:certificate/e9d39d56-c08c-4880-9c1a-da8361ee4f3e and arn:aws:acm:us-east-2:615299752206:certificate/087ea311-2df9-4f71-afc1-b995a8576533. Retrieve listener ARN from previous step output.",
            "status": "pending",
            "testStrategy": "Validate SNI certificate configuration using openssl s_client -connect <alb-dns-name>:443 -servername <domain> and verify certificate chain"
          },
          {
            "id": 3,
            "title": "Configure routing rules for HTTPS listener (port 443)",
            "description": "Create routing rules for the HTTPS listener to forward traffic based on path patterns to the appropriate target group",
            "dependencies": [
              2
            ],
            "details": "Create two routing rules using aws elbv2 create-rule: Rule 1 with priority 100 for path pattern '/app/*' forwarding to TrialFinderTargetGroup, and Rule 2 as default action (lowest priority) forwarding to TrialFinderTargetGroup. Use Type=forward action and retrieve target group ARN using aws elbv2 describe-target-groups.",
            "status": "pending",
            "testStrategy": "Test routing rules with curl -k https://<alb-dns-name>/app/test and curl -k https://<alb-dns-name>/other-path to verify proper forwarding"
          },
          {
            "id": 4,
            "title": "Update existing HTTP listener (port 80) with matching routing rules",
            "description": "Modify the existing port 80 HTTP listener to have matching routing rules consistent with the HTTPS listener configuration",
            "dependencies": [
              3
            ],
            "details": "Retrieve existing HTTP listener ARN using aws elbv2 describe-listeners for port 80. Delete existing rules if they differ from required configuration using aws elbv2 delete-rule. Create matching rules with same priorities as HTTPS listener: '/app/*' pattern (priority 100) and default action both forwarding to TrialFinderTargetGroup using aws elbv2 create-rule.",
            "status": "pending",
            "testStrategy": "Verify HTTP listener rules match HTTPS configuration and test with curl http://<alb-dns-name>/app/test and curl http://<alb-dns-name>/other-path"
          },
          {
            "id": 5,
            "title": "Validate target group association and health check configuration",
            "description": "Verify that the TrialFinderTargetGroup exists, is properly configured, and can receive traffic from both HTTP and HTTPS listeners",
            "dependencies": [
              4
            ],
            "details": "Use aws elbv2 describe-target-groups to confirm TrialFinderTargetGroup exists and retrieve its configuration. Verify target group is in same VPC as ALB using aws elbv2 describe-load-balancers. Check health check settings are appropriate for both listeners. Validate target registration and health status using aws elbv2 describe-target-health.",
            "status": "pending",
            "testStrategy": "Monitor target group health status and perform end-to-end testing of both HTTP and HTTPS traffic flow to ensure successful request processing and proper load balancing"
          }
        ]
      },
      {
        "id": 13,
        "title": "Refactor TrialFinderV2Stack into specialized ALB, ECS, and Data stacks with enhanced configuration management",
        "description": "Split the monolithic TrialFinderV2Stack (AppInfraCdkV1.Apps/TrialFinderV2/TrialFinderV2Stack.cs) into three specialized stacks (TrialFinderV2AlbStack, TrialFinderV2EcsStack, TrialFinderV2DataStack) with updated container configurations, GitHub Actions deployment pipeline, and proper stack dependencies.",
        "status": "pending",
        "dependencies": [
          3,
          6,
          7,
          8,
          10,
          12
        ],
        "priority": "medium",
        "details": "1. Create TrialFinderV2AlbStack:\n   - Extract Application Load Balancer, security groups, and networking components from existing TrialFinderV2Stack.cs\n   - Include listeners, target groups, and SSL certificate configurations\n   - Maintain existing ALB configuration while separating into dedicated stack\n   - Export necessary outputs for ECS stack consumption (ALB ARN, target group ARNs, security group IDs)\n\n2. Create TrialFinderV2EcsStack:\n   - Extract ECS cluster, services, and task definitions into dedicated stack\n   - Update ECS task to deploy nginx:latest container listening on port 8080\n   - Import ALB stack outputs for service configuration\n   - Implement container definitions with health checks and environment variables\n   - Configure service discovery and auto-scaling policies\n\n3. Create TrialFinderV2DataStack:\n   - Extract RDS instances, S3 buckets, and data-related resources\n   - Implement independent deployment capability\n   - Configure backup and retention policies\n   - Export database connection strings and S3 bucket names for application use\n\n4. Update TrialFinderV2 Configuration Management:\n   - Modify development.json, production.json, staging.json, and integration.json in AppInfraCdkV1.Apps/TrialFinderV2/config/\n   - Implement code-based container definitions with configuration overrides\n   - Add example containerDefinitions with doc-nlp-service-web configuration\n   - Include port mappings, environment variables, and health check configurations\n\n5. Update TrialFinderV2Stack.cs and TrialFinderV2Config.cs:\n   - Modify existing TrialFinderV2Stack.cs to support multi-stack architecture\n   - Update TrialFinderV2Config.cs to handle new configuration structure\n   - Implement cross-stack references and dependency management\n\n6. GitHub Actions Pipeline Updates:\n   - Create stack configuration file defining deployment order and dependencies\n   - Update infrastructure-pr.yml to validate all TrialFinderV2 stacks exist\n   - Implement separate cdk diff, synth, and deploy commands for each TrialFinderV2 stack\n   - Configure deployment dependencies: TrialFinderV2AlbStack  TrialFinderV2EcsStack  TrialFinderV2DataStack\n   - Add stack existence validation before deployment attempts\n\n7. Stack Dependency Management:\n   - Implement cross-stack references using CloudFormation exports/imports\n   - Configure proper dependency order in deployment pipeline\n   - Ensure TrialFinderV2EcsStack can reference TrialFinderV2AlbStack outputs\n   - Validate independent TrialFinderV2DataStack deployment capability",
        "testStrategy": "1. Validate Stack Separation:\n   - Deploy each TrialFinderV2 stack independently to verify proper resource allocation\n   - Confirm no circular dependencies exist between TrialFinderV2 stacks\n   - Test rollback capabilities for each individual TrialFinderV2 stack\n\n2. Test Container Configuration:\n   - Deploy nginx:latest container and verify port 8080 accessibility\n   - Validate containerDefinitions configuration loading from TrialFinderV2 JSON files\n   - Test health check functionality and container restart behavior\n\n3. GitHub Actions Validation:\n   - Run infrastructure-pr.yml workflow to verify TrialFinderV2 stack existence checks\n   - Test deployment pipeline with proper dependency ordering for TrialFinderV2 stacks\n   - Confirm cdk diff, synth, and deploy work for each TrialFinderV2 stack independently\n   - Validate deployment fails gracefully when dependencies are missing\n\n4. Integration Testing:\n   - Deploy all TrialFinderV2 stacks in correct order and verify application functionality\n   - Test ALB routing to ECS services across TrialFinderV2 stack boundaries\n   - Confirm data stack resources are accessible from TrialFinderV2 ECS services\n   - Validate cross-stack communication and resource sharing within TrialFinderV2 application\n\n5. Configuration Management Testing:\n   - Verify configuration overrides work correctly for different TrialFinderV2 environments\n   - Test container definition loading and application to TrialFinderV2 ECS tasks\n   - Confirm environment-specific settings are properly applied across all config files",
        "subtasks": [
          {
            "id": 1,
            "title": "Create TrialFinderV2AlbStack with networking components",
            "description": "Extract Application Load Balancer, security groups, and networking components from TrialFinderV2Stack.cs into a dedicated TrialFinderV2AlbStack with proper exports for ECS consumption.",
            "status": "pending",
            "dependencies": [],
            "details": "Create new TrialFinderV2AlbStack class extending Stack in AppInfraCdkV1.Apps/TrialFinderV2/ directory. Extract ALB, listeners, target groups, SSL certificate configurations, and security groups from existing TrialFinderV2Stack.cs. Configure CloudFormation exports for ALB ARN, target group ARNs, and security group IDs using CfnOutput. Maintain existing ALB configuration including health checks and routing rules. Update stack instantiation in CDK app to deploy TrialFinderV2AlbStack before TrialFinderV2EcsStack.",
            "testStrategy": "Deploy TrialFinderV2AlbStack independently and verify all networking components are created. Test ALB health checks and SSL certificate configuration. Validate CloudFormation exports are properly created for cross-stack references within TrialFinderV2 application."
          },
          {
            "id": 2,
            "title": "Create TrialFinderV2EcsStack with updated container configurations",
            "description": "Extract ECS cluster, services, and task definitions from TrialFinderV2Stack.cs into dedicated TrialFinderV2EcsStack with nginx:latest container deployment and ALB integration.",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Create new TrialFinderV2EcsStack class that imports TrialFinderV2AlbStack outputs using Fn.importValue(). Extract ECS cluster, services, and task definitions from existing TrialFinderV2Stack.cs. Update task definition to deploy nginx:latest container listening on port 8080. Configure container definitions with health checks, environment variables, and port mappings. Implement service discovery and auto-scaling policies. Connect ECS service to ALB target groups using imported values from TrialFinderV2AlbStack.",
            "testStrategy": "Deploy TrialFinderV2EcsStack after TrialFinderV2AlbStack and verify service registration with target groups. Test nginx container deployment and health checks. Validate auto-scaling policies trigger correctly under load. Confirm service discovery functionality within TrialFinderV2 application."
          },
          {
            "id": 3,
            "title": "Create TrialFinderV2DataStack with database and storage resources",
            "description": "Extract RDS instances, S3 buckets, and data-related resources from TrialFinderV2Stack.cs into independent TrialFinderV2DataStack with proper backup and retention policies.",
            "status": "pending",
            "dependencies": [],
            "details": "Create new TrialFinderV2DataStack class for all TrialFinderV2 data-related resources. Extract RDS instances, S3 buckets, and any other data storage components from existing TrialFinderV2Stack.cs. Configure backup policies, retention settings, and encryption for all data resources. Export database connection strings and S3 bucket names using CloudFormation outputs for TrialFinderV2 application consumption. Ensure TrialFinderV2DataStack can be deployed independently without dependencies on TrialFinderV2AlbStack or TrialFinderV2EcsStack.",
            "testStrategy": "Deploy TrialFinderV2DataStack independently and verify all data resources are created with proper configurations. Test backup and retention policies. Validate database connectivity and S3 bucket access permissions. Confirm CloudFormation exports are accessible for TrialFinderV2 application."
          },
          {
            "id": 4,
            "title": "Update TrialFinderV2 configuration management with containerDefinitions",
            "description": "Modify all TrialFinderV2 configuration files (development.json, production.json, staging.json, integration.json) to include containerDefinitions array with code-based container definitions and environment-specific overrides.",
            "status": "pending",
            "dependencies": [
              2
            ],
            "details": "Update AppInfraCdkV1.Apps/TrialFinderV2/config/development.json, production.json, staging.json, and integration.json files to include containerDefinitions array property. Implement containerDefinitions structure with doc-nlp-service-web configuration including image, port mappings (8080), environment variables, health check configurations, and resource limits. Create configuration overrides for different TrialFinderV2 environments. Update TrialFinderV2Stack.cs and TrialFinderV2Config.cs to read containerDefinitions from configuration files and apply them to ECS task definitions. Ensure configuration supports multiple container definitions per TrialFinderV2 service.",
            "testStrategy": "Validate configuration file syntax and structure for all TrialFinderV2 environments. Test container definition loading in TrialFinderV2Config.cs code. Deploy TrialFinderV2EcsStack with updated configuration and verify containers use settings from configuration files. Test environment-specific overrides work correctly across all TrialFinderV2 config files."
          },
          {
            "id": 5,
            "title": "Update GitHub Actions pipeline for TrialFinderV2 multi-stack deployment",
            "description": "Create stack configuration file and update GitHub Actions workflows to support independent deployment of TrialFinderV2AlbStack, TrialFinderV2EcsStack, and TrialFinderV2DataStack with proper dependency management.",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create TrialFinderV2-stack-config.json file defining deployment order (TrialFinderV2AlbStack  TrialFinderV2EcsStack  TrialFinderV2DataStack) and stack dependencies. Update infrastructure-pr.yml workflow to validate all three TrialFinderV2 stacks exist before deployment attempts. Implement separate CDK commands for diff, synth, and deploy for each TrialFinderV2 stack. Add stack existence validation step using cdk list command filtered for TrialFinderV2 stacks. Configure deployment matrix or sequential jobs respecting TrialFinderV2 dependency order. Update workflow to handle TrialFinderV2 stack-specific failures and rollback scenarios. Add conditional deployment logic based on changed files in TrialFinderV2 directory.",
            "testStrategy": "Test GitHub Actions workflow with all three TrialFinderV2 stacks. Verify deployment order is respected and dependencies are handled correctly for TrialFinderV2 application. Test workflow behavior when individual TrialFinderV2 stacks fail. Validate stack existence checks prevent deployment of non-existent TrialFinderV2 stacks. Confirm rollback capabilities work for each TrialFinderV2 stack independently."
          },
          {
            "id": 6,
            "title": "Update TrialFinderV2Stack.cs and TrialFinderV2Config.cs for multi-stack architecture",
            "description": "Modify existing TrialFinderV2Stack.cs and TrialFinderV2Config.cs files to support the new multi-stack architecture and cross-stack references.",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Update TrialFinderV2Stack.cs to either act as a parent stack that orchestrates the three specialized stacks or modify it to work alongside the new specialized stacks. Update TrialFinderV2Config.cs to handle the new configuration structure including containerDefinitions and cross-stack reference parameters. Implement methods to parse and validate the updated configuration files. Add support for environment-specific stack naming and cross-stack dependency resolution. Ensure backward compatibility during the transition period.",
            "testStrategy": "Compile and validate the updated TrialFinderV2Stack.cs and TrialFinderV2Config.cs files. Test configuration parsing for all environment files. Verify cross-stack references are properly resolved. Deploy the updated architecture and confirm all TrialFinderV2 components work together correctly."
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0",
      "created": "2025-01-12T00:21:00.000Z",
      "description": "Tasks for master context",
      "updated": "2025-07-13T14:53:15.096Z"
    }
  }
}