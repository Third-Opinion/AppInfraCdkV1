{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Review and update documentation files including README.md",
        "description": "Conduct a comprehensive review of all *.md documentation files in the project and update README.md to ensure accuracy and completeness.",
        "details": "1. Scan the entire project directory for all *.md files using find or glob patterns\n2. Read and analyze each documentation file to understand:\n   - Current project structure and components\n   - Installation and setup instructions\n   - Usage examples and API documentation\n   - Contributing guidelines\n   - License and project metadata\n3. Cross-reference documentation content with actual codebase to identify discrepancies\n4. Update README.md to include:\n   - Accurate project description and purpose\n   - Current installation instructions\n   - Updated usage examples\n   - Correct directory structure\n   - Valid links to other documentation\n   - Current dependencies and requirements\n   - Proper badges and status indicators\n5. Ensure consistency in formatting, style, and terminology across all documentation\n6. Remove outdated information and add missing sections\n7. Validate all external links and references",
        "testStrategy": "1. Verify all installation instructions work on a clean environment\n2. Test all code examples provided in documentation\n3. Confirm all internal links navigate to correct locations\n4. Validate external links are accessible and current\n5. Check that README.md accurately reflects current project state\n6. Ensure all referenced files and directories exist\n7. Verify documentation is consistent with package.json, requirements files, and other configuration\n8. Review with team members for accuracy and completeness",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Discovery and inventory of all markdown files",
            "description": "Scan the entire project directory to locate and catalog all markdown files including README.md, documentation directories, and any embedded docs",
            "dependencies": [],
            "details": "Use file search tools to find all .md files recursively. Create an inventory list with file paths, sizes, and last modified dates. Identify the main documentation structure and any orphaned or misplaced documentation files.\n<info added on 2025-07-12T00:40:17.153Z>\nDiscovery phase completed successfully. Total inventory: 34 markdown files identified across the project structure. File categorization reveals 5 main groups: Project root documentation (README.md, CLAUDE.md, AGENTS.md), centralized docs/ directory containing 12 files covering integration plans and GitHub setup guides, component-specific documentation in test and stack directories, infrastructure-related documentation, and AI assistant configuration files distributed across multiple IDE directories (.github/instructions/, .windsurf/rules/, .trae/rules/, .clinerules/). Notable size analysis shows taskmaster.md at 44K and dev_workflow.md at 32K as the largest files. Critical discovery: significant duplication of AI assistant rules and workflows across different IDE configuration directories, indicating need for consolidation strategy to reduce maintenance overhead and ensure consistency.\n</info added on 2025-07-12T00:40:17.153Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Analysis of existing documentation structure and content",
            "description": "Review the current documentation organization, content quality, and identify gaps or outdated information",
            "dependencies": [
              1
            ],
            "details": "Examine the documentation hierarchy, table of contents, navigation structure. Assess content completeness, accuracy, and readability. Identify sections that need updates, removal, or expansion based on current project state.\n<info added on 2025-07-12T00:41:00.809Z>\nDocumentation structure analysis reveals comprehensive main README.md with proper sections including status badges, overview, architecture, prerequisites, installation, configuration, usage, and security. The docs/ directory demonstrates good organization with setup guides, testing plans, and historical references. Component-level READMEs maintain appropriate focus and scope.\n\nKey findings: AGENTS.md duplicates CLAUDE.md content and should be consolidated. AI assistant configuration shows significant duplication across multiple IDE directories (.github/instructions/, .windsurf/rules/, .trae/rules/, .clinerules/) creating maintenance overhead. While the overall documentation hierarchy follows logical organization principles, reducing duplication and consolidating AI configuration files would improve maintainability and reduce inconsistency risks.\n\nRecommendation: Consolidate duplicate AI configuration into a single authoritative source and establish clear referencing strategy for IDE-specific needs.\n</info added on 2025-07-12T00:41:00.809Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Cross-referencing documentation with actual codebase state",
            "description": "Verify that documentation accurately reflects the current code implementation, APIs, and project structure",
            "dependencies": [
              1,
              2
            ],
            "details": "Compare documented APIs, configuration options, file structures, and code examples against actual implementation. Identify discrepancies between documented and actual behavior. Check that all referenced files, classes, and methods exist and function as described.\n<info added on 2025-07-12T00:41:50.722Z>\nCross-referenced documentation with codebase and found comprehensive alignment. README.md project structure accurately matches actual directories. Configuration examples align with appsettings.json structure including account IDs, regions, and environment names. Prerequisites correctly specify .NET 8.0 as confirmed in csproj files. Installation commands (dotnet restore, dotnet build) are valid. Usage commands match Program.cs implementation including --deploy-base and --validate-only flags. Architecture description accurately reflects code structure (Core/Stacks/Apps/Deploy). Naming conventions documentation matches NamingConvention.cs implementation. Security features documentation aligns with actual IAM/VPC implementation in stacks. No significant discrepancies identified between documentation and current codebase state.\n</info added on 2025-07-12T00:41:50.722Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Updating README.md with accurate project information",
            "description": "Revise the main README.md file to ensure it contains current, accurate, and comprehensive project information",
            "dependencies": [
              2,
              3
            ],
            "details": "Update project description, installation instructions, usage examples, API documentation, configuration details, and any project-specific information. Ensure the README serves as an effective entry point for new users and developers.\n<info added on 2025-07-12T00:42:52.518Z>\nImplementation completed successfully. README.md updated with corrected clone URL pointing to Third-Opinion organization and fixed GitHub Environment Setup documentation link to include proper docs/ directory path. Verified all other sections remain accurate including project structure, configuration examples, prerequisites, and commands. Documentation now fully synchronized with current codebase state.\n</info added on 2025-07-12T00:42:52.518Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Ensuring consistency and formatting across all docs",
            "description": "Standardize formatting, style, and structure across all documentation files for a cohesive experience",
            "dependencies": [
              2,
              4
            ],
            "details": "Apply consistent markdown formatting, heading structures, code block styling, and link formatting. Ensure uniform tone and style across all documentation. Fix any formatting inconsistencies or broken markdown syntax.\n<info added on 2025-07-12T00:43:33.016Z>\nSuccessfully completed documentation formatting and consistency improvements. Removed duplicate AGENTS.md file that was identical to CLAUDE.md content. Corrected test command in AppInfraCdkV1.Tests/README.md from incorrect directory path to proper 'dotnet test' command. Standardized markdown structure across all documentation files with consistent headers, code block formatting, and navigation patterns. All documentation now maintains unified style and proper markdown syntax throughout the project.\n</info added on 2025-07-12T00:43:33.016Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Validation and testing of all documentation content including links and examples",
            "description": "Test all links, code examples, and instructions to ensure they work correctly and provide accurate guidance",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Verify all external and internal links are functional. Test code examples and snippets to ensure they execute correctly. Validate installation and setup instructions. Check that all referenced resources are accessible and current.\n<info added on 2025-07-12T00:44:25.019Z>\nDocumentation validation completed successfully. All core commands verified functional: dotnet build executes without errors, dotnet run with --validate-only and --show-names-only flags work as documented and produce expected outputs, dotnet test performs test discovery correctly. Installation procedures and usage instructions tested and confirmed accurate. All code examples and command snippets execute properly. Documentation now provides reliable guidance for end users.\n</info added on 2025-07-12T00:44:25.019Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Enable Container Insights and enhanced observability for WebApplicationStack",
        "description": "Update the CDK WebApplicationStack to integrate AWS Container Insights with CloudWatch monitoring, custom metrics, and comprehensive logging for enhanced observability of containerized applications.",
        "details": "1. Modify the WebApplicationStack class to enable Container Insights on ECS clusters:\n   - Add containerInsights: ecs.ContainerInsights.ENABLED to cluster configuration\n   - Configure CloudWatch log groups with appropriate retention policies\n   - Set up custom CloudWatch metrics for application performance monitoring\n\n2. Implement comprehensive logging strategy:\n   - Configure structured logging with JSON format for better parsing\n   - Set up log aggregation using CloudWatch Logs\n   - Add application-level metrics and tracing capabilities\n   - Configure log retention policies based on environment (dev/prod)\n\n3. Add monitoring and alerting infrastructure:\n   - Create CloudWatch dashboards for key application metrics\n   - Set up CloudWatch alarms for critical thresholds (CPU, memory, error rates)\n   - Configure SNS topics for alert notifications\n   - Implement custom metrics for business logic monitoring\n\n4. Update CDK constructs to include:\n   - Enhanced ECS task definitions with logging drivers\n   - CloudWatch agent configuration for detailed metrics collection\n   - X-Ray tracing integration for distributed tracing\n   - Cost optimization through appropriate log retention and metric filtering\n\n5. Environment-specific configuration:\n   - Different monitoring levels for development vs production\n   - Configurable alert thresholds based on environment\n   - Resource tagging strategy for cost allocation and filtering",
        "testStrategy": "1. Deploy the updated stack to development environment and verify Container Insights is enabled in ECS console\n2. Validate CloudWatch metrics are being collected by checking the Container Insights dashboard\n3. Test log aggregation by generating application logs and confirming they appear in CloudWatch Logs with correct formatting\n4. Verify custom metrics are being published by triggering application events and checking CloudWatch metrics\n5. Test alerting by intentionally triggering threshold breaches and confirming SNS notifications are sent\n6. Validate X-Ray tracing by making application requests and reviewing trace data in X-Ray console\n7. Check cost impact by reviewing CloudWatch billing and ensuring retention policies are applied correctly\n8. Perform end-to-end monitoring test by simulating application failures and verifying detection through dashboards and alerts",
        "status": "done",
        "dependencies": [
          1,
          "4",
          "5"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Create comprehensive ALB and ECS infrastructure for TrialFinderV2Stack",
        "description": "Implement Application Load Balancer, ECS Service/Task, security groups, and configuration management for TrialFinderV2Stack with comprehensive AWS resource setup.",
        "details": "1. AWS CLI Resource Inspection:\n   - Inspect existing ALB (arn:aws:elasticloadbalancing:us-east-2:615299752206:loadbalancer/app/dev-ecs-alb/5e4db6036255c842) using aws elbv2 describe-load-balancers\n   - Examine ECS service (arn:aws:ecs:us-east-2:615299752206:service/dev-trail-finder-v2/trial-finder-service) configuration\n   - Review security group sg-05787d59ddec14f04 settings\n   - Document existing task definition and execution roles\n\n2. ALB Infrastructure:\n   - Create ALB in new VPC dev-shared-vpc-ue2-main using existing settings as template\n   - Deploy ALB in public subnets for internet accessibility\n   - Create dedicated S3 bucket for ALB access logs with proper bucket policy\n   - Implement ALB security group allowing HTTPS (443) ingress from 0.0.0.0/0\n   - Configure outbound rules for ALB to reach ECS targets\n\n3. ECS Service and Task Definition:\n   - Reference existing ECS cluster from WebApplicationStack\n   - Create new ECS service in private subnets of shared VPC\n   - Copy and adapt existing trial-finder-v2 task definition\n   - Configure service to use existing task and execution roles\n   - Set up target group (HTTP/80) and register with new ALB\n   - Configure health checks and service auto-scaling parameters\n\n4. Security Group Configuration:\n   - Create ECS security group based on sg-05787d59ddec14f04\n   - Allow ingress from ALB security group on container port\n   - Add loopback rule for port 8080 (127.0.0.1/32)\n   - Configure egress rules for outbound internet access\n\n5. Configuration Management:\n   - Create JSON configuration file for environment variables\n   - Structure config with container name as top-level key\n   - Update task definition to reference JSON configuration\n   - Implement parameter validation and type checking\n\n6. Documentation and TODOs:\n   - Add comprehensive inline comments explaining resource relationships\n   - Document missing configurations with //TODO comments\n   - Create summary of implemented vs required resources\n   - Note dependencies on future listener and certificate tasks",
        "testStrategy": "1. Deploy TrialFinderV2Stack to development environment and verify all resources are created successfully\n2. Validate ALB is accessible and properly configured by checking AWS console and CLI\n3. Confirm ECS service starts successfully and registers healthy targets with ALB target group\n4. Test security group rules by attempting connections from ALB to ECS and verifying port 8080 loopback\n5. Verify S3 access logs are being written to the new bucket\n6. Validate JSON configuration is properly loaded by ECS task by checking container environment variables\n7. Test service scaling and health check functionality\n8. Confirm integration with existing WebApplicationStack ECS cluster\n9. Verify private subnet deployment and proper VPC networking\n10. Document any missing configurations or failed validations for future resolution",
        "status": "done",
        "dependencies": [
          1,
          "2"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "AWS resource inspection and documentation of existing infrastructure",
            "description": "Inspect current AWS infrastructure including VPCs, subnets, security groups, and ECS clusters to document existing resources that will be referenced in ALB and ECS setup",
            "dependencies": [],
            "details": "Use AWS CLI to gather information about existing WebApplicationStack cluster, VPC configuration, subnet layouts, and current security group configurations. Document findings to inform subsequent infrastructure creation steps.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Security group setup for both ALB and ECS with proper ingress/egress rules",
            "description": "Create and configure security groups for ALB and ECS services with appropriate ingress/egress rules for secure communication",
            "dependencies": [
              1
            ],
            "details": "Define security groups for ALB (allowing HTTP/HTTPS traffic) and ECS tasks (allowing traffic from ALB). Configure proper port mappings and source/destination rules based on discovered infrastructure.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "ALB creation with security groups and S3 logging configuration",
            "description": "Create Application Load Balancer with proper security group attachment and S3 access logging configuration",
            "dependencies": [
              2
            ],
            "details": "Implement ALB creation using CDK constructs, attach security groups created in previous step, configure S3 bucket for access logs, and set up proper listener configurations for HTTP/HTTPS traffic.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "ECS task definition and service configuration referencing WebApplicationStack cluster",
            "description": "Create ECS task definition and service configuration that properly references the existing WebApplicationStack cluster",
            "dependencies": [
              2
            ],
            "details": "Define ECS task with container specifications, CPU/memory allocation, and networking configuration. Create ECS service that references the existing cluster and uses the security groups configured earlier.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "JSON configuration management system implementation",
            "description": "Implement a configuration management system using JSON files to manage ALB and ECS settings dynamically",
            "dependencies": [
              3,
              4
            ],
            "details": "Create JSON configuration files for ALB and ECS parameters, implement CDK code to read and apply these configurations, and establish a system for environment-specific settings management.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Integration testing and comprehensive documentation with TODO tracking",
            "description": "Perform integration testing of ALB and ECS setup, create comprehensive documentation, and implement TODO tracking system",
            "dependencies": [
              5
            ],
            "details": "Test ALB routing to ECS services, verify security group rules, validate S3 logging functionality, document the complete infrastructure setup process, and create a TODO tracking system for ongoing maintenance tasks.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Deploy EnvironmentBaseStack with shared VPC infrastructure",
        "description": "Deploy the foundational networking infrastructure including VPC, subnets, NAT gateways, and security groups to support ALB and ECS deployments.",
        "details": "1. Deploy EnvironmentBaseStack using CDK:\n   - Execute 'cdk deploy EnvironmentBaseStack' using to-dev-admin profile\n   - Verify stack deployment creates dev-shared-vpc-ue2-main VPC\n   - Confirm public and private subnets are created across multiple AZs\n   - Validate NAT gateways are provisioned for private subnet internet access\n   - Ensure shared security groups are created with appropriate ingress/egress rules\n\n2. AWS CLI Validation:\n   - Use 'aws ec2 describe-vpcs' to verify VPC creation and configuration\n   - Check subnet configuration with 'aws ec2 describe-subnets'\n   - Validate NAT gateway deployment with 'aws ec2 describe-nat-gateways'\n   - Inspect security groups using 'aws ec2 describe-security-groups'\n   - Confirm route tables are properly configured for public/private routing\n\n3. Infrastructure Verification:\n   - Document VPC ID, subnet IDs, and security group IDs for reference\n   - Verify internet gateway attachment and routing configuration\n   - Confirm cross-AZ redundancy for high availability\n   - Validate CIDR block allocation aligns with organizational standards",
        "testStrategy": "1. Verify successful CDK deployment by checking AWS CloudFormation console for EnvironmentBaseStack completion status\n2. Validate VPC infrastructure using AWS CLI commands to confirm all networking components are created\n3. Test internet connectivity from private subnets through NAT gateways using EC2 instances or VPC endpoints\n4. Confirm security group rules allow appropriate traffic flows for ALB and ECS services\n5. Document all resource ARNs and IDs for use in dependent application infrastructure tasks\n6. Perform cleanup test by destroying and redeploying stack to ensure reproducibility",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Deploy WebApplicationStack with ECS cluster infrastructure",
        "description": "Create and deploy ECS cluster with appropriate capacity providers, auto-scaling, and VPC integration to support TrialFinderV2Stack services.",
        "details": "1. Deploy WebApplicationStack using CDK:\n   - Execute 'cdk deploy WebApplicationStack' using to-dev-admin profile\n   - Create ECS cluster with appropriate naming convention (dev-web-app-cluster-ue2)\n   - Configure cluster with EC2 and Fargate capacity providers for flexible workload placement\n   - Set up cluster auto-scaling policies for cost optimization and performance\n   - Integrate cluster with shared VPC infrastructure from EnvironmentBaseStack\n\n2. Cluster Configuration:\n   - Enable cluster auto-scaling with target utilization thresholds\n   - Configure capacity providers with managed scaling enabled\n   - Set up appropriate IAM roles for cluster operations and task execution\n   - Ensure cluster is deployed in private subnets for security\n   - Configure cluster tags for resource management and cost allocation\n\n3. Infrastructure Validation:\n   - Verify cluster creation using 'aws ecs describe-clusters' CLI command\n   - Document cluster ARN for reference by TrialFinderV2Stack services\n   - Confirm capacity providers are properly registered and active\n   - Validate cluster networking connectivity within VPC\n   - Prepare cluster for Container Insights enablement in subsequent tasks",
        "testStrategy": "1. Verify successful CDK deployment by checking AWS CloudFormation console for WebApplicationStack completion status\n2. Validate ECS cluster creation using 'aws ecs describe-clusters --clusters <cluster-name>' to confirm cluster is active\n3. Test capacity providers are properly configured using 'aws ecs describe-capacity-providers'\n4. Confirm cluster networking by verifying it's deployed in correct VPC and subnets\n5. Validate auto-scaling configuration is active and properly configured\n6. Document cluster ARN and verify it can be referenced by dependent services\n7. Test cluster readiness by attempting to run a simple task definition to ensure infrastructure is functional",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Update IAM policies and roles for CDK deployment with proper permissions",
        "description": "Update the IAM policy dev-g-policy-g-gh-cdk-deploy to allow updating policies and roles it created, rename the GitHub Actions role to dev-cdk-role-ue2-github-actions, add 'cdk' to the application enum, and remove CDKDeployPolicy in favor of dev-g-policy-g-gh-cdk-deploy.",
        "details": "1. Update IAM Policy dev-g-policy-g-gh-cdk-deploy:\n   - Use AWS CLI with to-dev-admin profile to retrieve current policy version: aws iam get-policy-version --policy-arn arn:aws:iam::615299752206:policy/dev-g-policy-g-gh-cdk-deploy --version-id <current-version>\n   - Add new permissions to allow updating IAM policies and roles with resource constraints:\n     * iam:UpdateAssumeRolePolicy with resource constraint to roles created by this policy\n     * iam:PutRolePolicy, iam:DeleteRolePolicy for inline policies\n     * iam:AttachRolePolicy, iam:DetachRolePolicy for managed policies\n     * iam:CreatePolicyVersion, iam:DeletePolicyVersion for policy updates\n   - Include condition to restrict updates only to resources tagged with Creator: CDK or matching naming pattern dev-cdk-*\n   - Create new policy version: aws iam create-policy-version --policy-arn <arn> --policy-document file://updated-policy.json --set-as-default\n\n2. Rename IAM Role:\n   - Document current role configuration: aws iam get-role --role-name dev-tfv2-role-ue2-github-actions\n   - Export trust policy and attached policies\n   - Create new role dev-cdk-role-ue2-github-actions with same trust policy\n   - Attach dev-g-policy-g-gh-cdk-deploy to the new role\n   - Update GitHub Actions secrets/variables to use new role ARN\n   - Test new role permissions before deleting old role\n\n3. Application Enum Update:\n   - Locate application enum definition in codebase (likely in constants or config file)\n   - Add 'cdk' as a valid application value\n   - Update any validation logic that uses this enum\n   - Ensure CDK stacks use the new 'cdk' application tag\n\n4. Remove CDKDeployPolicy:\n   - Search codebase for references to CDKDeployPolicy\n   - Replace all references with dev-g-policy-g-gh-cdk-deploy\n   - Update any CloudFormation/CDK templates that create or attach CDKDeployPolicy\n   - Delete the CDKDeployPolicy from AWS account if it exists as a managed policy\n\n5. Update GitHub Actions Workflow:\n   - Modify .github/workflows files to use new role name\n   - Update any environment variables referencing the old role\n   - Ensure OIDC trust relationship is maintained with new role",
        "testStrategy": "1. Validate IAM policy updates:\n   - Use aws iam simulate-principal-policy to test new permissions work correctly\n   - Attempt to update a test IAM role/policy created by CDK to verify constraints\n   - Confirm updates to resources NOT created by CDK are denied\n\n2. Test role rename:\n   - Trigger a GitHub Actions workflow using the new role\n   - Verify CDK deployment succeeds with new role permissions\n   - Confirm old role name no longer works\n\n3. Verify application enum:\n   - Deploy a test CDK stack with 'cdk' application tag\n   - Check AWS resources are properly tagged with Application: cdk\n   - Validate any application-specific logic handles 'cdk' value\n\n4. Confirm CDKDeployPolicy removal:\n   - Search AWS account for any remaining references to CDKDeployPolicy\n   - Verify all CDK deployments work without CDKDeployPolicy\n   - Check CloudFormation stacks no longer reference the old policy\n\n5. End-to-end deployment test:\n   - Run complete CDK deployment pipeline with all changes\n   - Verify GitHub Actions can assume new role and deploy successfully\n   - Test updating an existing CDK-deployed IAM resource",
        "status": "done",
        "dependencies": [
          1,
          4
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Update dev-g-policy-g-gh-cdk-deploy IAM policy permissions",
            "description": "Update the existing dev-g-policy-g-gh-cdk-deploy policy to include permissions for self-management capabilities including IAM policy operations, role management, and CDK deployment permissions",
            "dependencies": [],
            "details": "Add permissions for iam:CreatePolicy, iam:DeletePolicy, iam:CreatePolicyVersion, iam:DeletePolicyVersion, iam:GetPolicy, iam:GetPolicyVersion, iam:ListPolicyVersions, iam:CreateRole, iam:DeleteRole, iam:AttachRolePolicy, iam:DetachRolePolicy, iam:PutRolePolicy, iam:DeleteRolePolicy, and ensure CDK deployment permissions are comprehensive",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create dev-cdk-role-ue2-github-actions IAM role",
            "description": "Create a new IAM role specifically for GitHub Actions CDK deployments with appropriate trust policy for OIDC authentication and attach the updated dev-g-policy-g-gh-cdk-deploy policy",
            "dependencies": [
              1
            ],
            "details": "Configure trust policy for GitHub OIDC provider, set appropriate session duration, attach dev-g-policy-g-gh-cdk-deploy policy, and ensure role naming follows organization conventions",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add 'cdk' to application enum in codebase",
            "description": "Update the application enum/configuration in the codebase to include 'cdk' as a valid application identifier for infrastructure deployments",
            "dependencies": [],
            "details": "Locate application enum definition (likely in a constants or configuration file), add 'cdk' entry, update any validation logic, and ensure consistency across the codebase",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Remove CDKDeployPolicy references and update to dev-g-policy-g-gh-cdk-deploy",
            "description": "Search codebase for all CDKDeployPolicy references and replace them with dev-g-policy-g-gh-cdk-deploy, ensuring proper policy attachment in all relevant configurations",
            "dependencies": [
              1,
              3
            ],
            "details": "Update CDK stack definitions, IAM role configurations, deployment scripts, and any documentation referencing the old policy name",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Update GitHub Actions workflows for new role",
            "description": "Modify GitHub Actions workflow files to use the new dev-cdk-role-ue2-github-actions role for CDK deployments and ensure proper OIDC authentication configuration",
            "dependencies": [
              2,
              4
            ],
            "details": "Update role ARN in workflow files, verify OIDC provider configuration, test authentication flow, update environment variables if needed, and ensure workflows maintain proper permissions",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement ECS task execution and task roles with Secrets Manager access",
        "description": "Configure ECS task execution role and task roles to securely access AWS Secrets Manager secrets using environment-based naming conventions and resource-scoped IAM policies.",
        "details": "1. Create IAM Policies for Secrets Manager Access:\n   - Define policy for task execution role to decrypt secrets using KMS\n   - Create environment-specific policies with resource patterns:\n     * Development: arn:aws:secretsmanager:us-east-2:615299752206:secret:/dev/myapp/*\n     * Production: arn:aws:secretsmanager:us-east-2:442042533707:secret:/prod/myapp/*\n   - Include actions: secretsmanager:GetSecretValue, secretsmanager:DescribeSecret\n   - Add KMS permissions for secret decryption\n\n2. Update ECS Task Execution Role:\n   - Modify existing execution role or create new one with pattern: {environment}-ecs-task-execution-role-{region}\n   - Attach AWS managed policy: arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy\n   - Add custom policy for Secrets Manager access with least privilege\n   - Enable pulling secrets for container environment variables\n\n3. Create ECS Task Roles:\n   - Implement task role pattern: {environment}-{application}-task-role-{region}\n   - Create separate roles for each environment (dev, staging, prod)\n   - Attach environment-specific Secrets Manager policies\n   - Implement resource constraints using naming convention paths\n\n4. Create Test Secrets in Secrets Manager:\n   - Development secrets:\n     * /dev/myapp/database-connection\n     * /dev/myapp/api-key\n     * /dev/myapp/service-credentials\n   - Production secrets:\n     * /prod/myapp/database-connection\n     * /prod/myapp/api-key\n     * /prod/myapp/service-credentials\n   - Use AWS CLI: aws secretsmanager create-secret --name /dev/myapp/database-connection --secret-string '{\"username\":\"devuser\",\"password\":\"devpass\"}'\n\n5. Update CDK Stack Implementation:\n   - Modify TrialFinderV2Stack to use new task execution role\n   - Configure task definition to reference secrets as environment variables\n   - Use secrets property in container definition:\n     ```typescript\n     secrets: {\n       DB_CONNECTION: ecs.Secret.fromSecretsManager(dbSecret),\n       API_KEY: ecs.Secret.fromSecretsManager(apiKeySecret)\n     }\n     ```\n\n6. Implement Resource Scoping:\n   - Use IAM policy conditions to enforce path-based access\n   - Add explicit Deny statements for cross-environment access\n   - Example policy condition:\n     ```json\n     \"Condition\": {\n       \"StringLike\": {\n         \"secretsmanager:SecretId\": \"/{environment}/{application-name}/*\"\n       }\n     }\n     ```",
        "testStrategy": "1. Create Integration Test Task:\n   - Deploy a test ECS task with minimal container that includes AWS CLI\n   - Configure task to use the new task role\n   - Mount test script that attempts to read secrets\n\n2. Test Allowed Access:\n   - Run aws secretsmanager get-secret-value --secret-id /dev/myapp/database-connection\n   - Verify successful retrieval of development secrets\n   - Confirm all environment-specific secrets are accessible\n\n3. Test Denied Access:\n   - Attempt to read production secrets from development task role\n   - Run aws secretsmanager get-secret-value --secret-id /prod/myapp/database-connection\n   - Verify access is denied with appropriate error message\n   - Test cross-application access is blocked\n\n4. Validate ECS Integration:\n   - Deploy updated TrialFinderV2Stack with secrets configuration\n   - Verify containers start successfully with injected secrets\n   - Check CloudWatch logs to ensure no secret values are exposed\n   - Confirm environment variables are properly set from secrets\n\n5. Security Validation:\n   - Use AWS Access Analyzer to verify IAM policies are correctly scoped\n   - Run aws iam simulate-principal-policy to test various access scenarios\n   - Ensure task execution role can only access secrets during task startup\n   - Verify task role maintains access throughout task lifecycle",
        "status": "pending",
        "dependencies": [
          3,
          5
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create IAM policies for Secrets Manager access",
            "description": "Design and implement IAM policies that provide environment-specific access to Secrets Manager resources using path-based restrictions",
            "dependencies": [],
            "details": "Create separate IAM policies for dev, staging, and production environments. Each policy should restrict access to secrets under specific paths (e.g., /dev/*, /staging/*, /prod/*). Include conditions to prevent cross-environment access and ensure proper resource tagging. Define actions like secretsmanager:GetSecretValue, secretsmanager:DescribeSecret with appropriate resource constraints.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure ECS task execution role with permissions",
            "description": "Set up the ECS task execution role with required permissions for KMS decryption and Secrets Manager access",
            "dependencies": [
              1
            ],
            "details": "Create or update the ECS task execution role to include permissions for KMS key usage (kms:Decrypt, kms:DescribeKey) and Secrets Manager operations. Ensure the execution role can pull container images from ECR and write logs to CloudWatch. Apply least privilege principles and include condition keys for service-specific access.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create environment-specific ECS task roles",
            "description": "Implement separate ECS task roles for each environment with appropriate resource constraints and permissions",
            "dependencies": [
              1,
              2
            ],
            "details": "Create distinct task roles for dev, staging, and production environments. Each role should have environment-specific permissions and resource access patterns. Include necessary permissions for application functionality while maintaining strict boundaries between environments. Implement resource tags and conditions to enforce separation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Set up test secrets in Secrets Manager",
            "description": "Create test secrets in AWS Secrets Manager following the established naming conventions for each environment",
            "dependencies": [
              1
            ],
            "details": "Create sample secrets in Secrets Manager with proper naming conventions (e.g., /dev/app/db-connection, /staging/app/api-key). Include various secret types like database credentials, API keys, and configuration values. Tag secrets appropriately for environment identification and access control. Ensure KMS encryption is properly configured for each secret.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Update CDK stack for role integration and secret injection",
            "description": "Modify the CDK stack to use the new IAM roles and implement secret injection as environment variables in ECS tasks",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Update the CDK code to reference the new IAM roles in ECS task definitions. Implement secret retrieval from Secrets Manager and injection as environment variables using CDK's ECS patterns. Configure the task definition to use the appropriate execution and task roles. Ensure proper error handling and fallback mechanisms.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Test IAM policy conditions and access prevention",
            "description": "Implement comprehensive tests to verify cross-environment access prevention and validate all IAM policy conditions",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create test scenarios to verify that dev environment cannot access prod secrets and vice versa. Test KMS key permissions and encryption/decryption operations. Validate that ECS tasks can only access their designated secrets. Implement automated tests using AWS SDK to verify policy effectiveness. Document test results and any security findings.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Update ALB security group to only allow HTTPS traffic on port 443",
        "description": "Modify the existing ALB security group sg-0f145c092dfa6267b to enforce HTTPS-only traffic by removing HTTP (port 80) rules and updating the security group description to accurately reflect its purpose.",
        "details": "1. Retrieve Current Security Group Configuration:\n   - Use AWS CLI with to-dev-admin profile: aws ec2 describe-security-groups --group-ids sg-0f145c092dfa6267b --region us-east-2\n   - Document all existing ingress and egress rules\n   - Identify any HTTP (port 80) rules that need removal\n   - Save current configuration for rollback purposes\n\n2. Remove HTTP Ingress Rules:\n   - Identify all ingress rules allowing port 80 traffic\n   - Use aws ec2 revoke-security-group-ingress to remove each HTTP rule:\n     * aws ec2 revoke-security-group-ingress --group-id sg-0f145c092dfa6267b --protocol tcp --port 80 --cidr 0.0.0.0/0\n   - Remove any additional port 80 rules with different source configurations\n\n3. Verify HTTPS Rules:\n   - Ensure port 443 ingress rules exist from appropriate sources (0.0.0.0/0 for public ALB)\n   - If missing, add HTTPS rule: aws ec2 authorize-security-group-ingress --group-id sg-0f145c092dfa6267b --protocol tcp --port 443 --cidr 0.0.0.0/0\n   - Confirm egress rules allow responses (typically all traffic egress is allowed)\n\n4. Update Security Group Description:\n   - Generate new description: \"ALB security group - HTTPS only (port 443) for secure web traffic\"\n   - Update using: aws ec2 update-security-group-rule-descriptions-ingress --group-id sg-0f145c092dfa6267b\n   - Include timestamp and change reason in description\n\n5. Update CDK Code:\n   - Locate security group definition in CDK stack (likely in TrialFinderV2Stack or WebApplicationStack)\n   - Update ingress rules to only allow HTTPS:\n     * securityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(443), 'Allow HTTPS traffic')\n   - Remove any HTTP ingress rules from code\n   - Update security group description in CDK constructor\n\n6. Validate ALB Configuration:\n   - Check ALB listeners to ensure only HTTPS listener exists\n   - If HTTP listener exists, consider adding HTTP to HTTPS redirect before removal\n   - Update target group health checks if currently using HTTP",
        "testStrategy": "1. Verify Security Group Rules:\n   - Run aws ec2 describe-security-groups --group-ids sg-0f145c092dfa6267b to confirm only port 443 ingress exists\n   - Validate no port 80 rules remain in the security group\n   - Confirm security group description accurately reflects HTTPS-only configuration\n\n2. Test ALB Accessibility:\n   - Attempt HTTP connection to ALB DNS name - should fail or timeout\n   - Test HTTPS connection to ALB DNS name - should succeed\n   - Use curl commands: curl -I http://[alb-dns] (should fail) and curl -I https://[alb-dns] (should succeed)\n\n3. Validate Application Functionality:\n   - Ensure application remains accessible via HTTPS after changes\n   - Test all application endpoints using HTTPS protocol\n   - Monitor ALB target health to ensure no disruption to healthy targets\n\n4. CDK Deployment Test:\n   - Run cdk diff to review security group changes\n   - Deploy updated CDK stack: cdk deploy TrialFinderV2Stack\n   - Verify CloudFormation successfully updates security group without replacing it\n\n5. Security Validation:\n   - Run AWS Security Hub or trusted advisor checks on the ALB\n   - Confirm compliance with HTTPS-only requirements\n   - Document security improvement in change log",
        "status": "pending",
        "dependencies": [
          3,
          4
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Create VPC endpoints and security group for secure AWS service access",
        "description": "Create a security group allowing HTTPS traffic from ECS services and deploy four VPC endpoints for AWS services, copying configuration from existing endpoints to ensure secure private connectivity within the VPC.",
        "details": "1. Create VPC Endpoints Security Group:\n   - Use AWS CLI with to-dev-admin profile to create new security group in the shared VPC\n   - Name: dev-vpc-endpoints-sg-ue2\n   - Description: \"Security group for VPC endpoints allowing HTTPS access from ECS services\"\n   - Add ingress rule: Protocol TCP, Port 443, Source: VPC CIDR block (retrieve from EnvironmentBaseStack)\n   - Add egress rule: Allow all outbound traffic (default)\n   - Tag with standard tags: Environment=dev, ManagedBy=cdk\n\n2. Inspect Existing VPC Endpoints:\n   - Run aws ec2 describe-vpc-endpoints for each endpoint ID:\n     * vpce-0d9d53b3e72551b76\n     * vpce-0ed96b383d694eb96\n     * vpce-09e1f74448c3da307\n     * vpce-0bd1406eb3344bc82\n   - Document service names, subnet configurations, and current security groups\n   - Identify route table associations and DNS settings\n\n3. Create Four New VPC Endpoints:\n   - S3 Gateway Endpoint:\n     * Service: com.amazonaws.us-east-2.s3\n     * Type: Gateway\n     * Route tables: Associate with private subnet route tables\n     * Policy: Full access (default)\n   - ECR API Interface Endpoint:\n     * Service: com.amazonaws.us-east-2.ecr.api\n     * Type: Interface\n     * Subnets: Deploy to all private subnets\n     * Security group: dev-vpc-endpoints-sg-ue2\n     * Enable private DNS\n   - ECR DKR Interface Endpoint:\n     * Service: com.amazonaws.us-east-2.ecr.dkr\n     * Type: Interface\n     * Subnets: Deploy to all private subnets\n     * Security group: dev-vpc-endpoints-sg-ue2\n     * Enable private DNS\n   - Secrets Manager Interface Endpoint:\n     * Service: com.amazonaws.us-east-2.secretsmanager\n     * Type: Interface\n     * Subnets: Deploy to all private subnets\n     * Security group: dev-vpc-endpoints-sg-ue2\n     * Enable private DNS\n\n4. Update CDK Code:\n   - Add VPC endpoint constructs to EnvironmentBaseStack\n   - Create security group construct with proper ingress rules\n   - Implement interface endpoints with DNS and security group configuration\n   - Add gateway endpoint for S3 with route table associations\n   - Export endpoint IDs and security group ID for use by other stacks",
        "testStrategy": "1. Verify Security Group Configuration:\n   - Run aws ec2 describe-security-groups to confirm the new security group exists\n   - Validate ingress rule allows HTTPS (443) from VPC CIDR\n   - Confirm security group is associated with all interface endpoints\n\n2. Test VPC Endpoints:\n   - Use aws ec2 describe-vpc-endpoints to verify all four endpoints are created\n   - Confirm each endpoint is in 'available' state\n   - Validate subnet associations match private subnet configuration\n   - Check DNS names are properly configured for interface endpoints\n\n3. Functional Testing:\n   - Deploy a test ECS task in the private subnet\n   - Attempt to pull an image from ECR using the VPC endpoint\n   - Test secret retrieval from Secrets Manager through VPC endpoint\n   - Verify S3 access works through gateway endpoint\n   - Monitor VPC Flow Logs to confirm traffic routes through endpoints\n\n4. DNS Resolution Testing:\n   - From an EC2 instance in the private subnet, run nslookup for service endpoints\n   - Confirm DNS resolves to private IP addresses within the VPC\n   - Validate no internet gateway traffic for AWS service calls",
        "status": "pending",
        "dependencies": [
          4,
          5
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create VPC endpoints security group with HTTPS configuration",
            "description": "Create a dedicated security group for VPC endpoints that allows HTTPS (port 443) ingress from the VPC CIDR range and appropriate egress rules",
            "dependencies": [],
            "details": "Define a new security group in CDK that will be used by all interface endpoints. Configure ingress rule for port 443 from VPC CIDR block, and egress rules as needed. Add proper tagging and naming conventions consistent with the existing infrastructure",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement S3 gateway endpoint with route table associations",
            "description": "Create an S3 gateway endpoint and associate it with all private subnet route tables to enable private S3 connectivity",
            "dependencies": [],
            "details": "Use CDK to create an S3 gateway endpoint in the VPC. Automatically associate the endpoint with all private subnet route tables. Ensure the endpoint policy allows necessary S3 operations for ECR image storage and application needs",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Configure ECR interface endpoints with DNS and security",
            "description": "Create interface endpoints for ECR API (ecr.api) and Docker Registry (ecr.dkr) with private DNS enabled and appropriate security group attachment",
            "dependencies": [
              1
            ],
            "details": "Implement two interface endpoints for ECR services using CDK. Enable private DNS for both endpoints. Attach the VPC endpoints security group created in subtask 1. Deploy endpoints across all availability zones for high availability",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Secrets Manager endpoint and consolidate endpoint management",
            "description": "Implement Secrets Manager interface endpoint and refactor CDK code to manage all VPC endpoints in a centralized, maintainable structure",
            "dependencies": [
              1,
              3
            ],
            "details": "Add Secrets Manager interface endpoint with the same security and DNS configuration. Create a reusable CDK construct or function to standardize endpoint creation. Ensure all endpoints are properly tagged and follow naming conventions. Update documentation to reflect the private connectivity setup",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Create ECS container security group (ContainerFromAlbSecurityGroup) for all ECS services",
        "description": "Configure a new security group for ECS containers with specific inbound rules allowing traffic from ALB and self-reference, and outbound rules for HTTP/HTTPS traffic to internet and VPC endpoints.",
        "details": "1. Create ECS Container Security Group:\n   - Use AWS CLI with to-dev-admin profile to create security group in the shared VPC\n   - Name: dev-ecs-container-sg-ue2 (ContainerFromAlbSecurityGroup)\n   - Description: \"Security group for ECS containers allowing traffic from ALB and internal communication\"\n   - Retrieve VPC ID from EnvironmentBaseStack using AWS CLI\n   - Tag with standard tags: Environment=dev, ManagedBy=cdk\n\n2. Configure Inbound Rules:\n   - Rule 1: All TCP (0-65535) from 0.0.0.0/0 with Description=\"Cleanup\" (temporary rule for initial setup)\n   - Rule 2: All TCP (0-65535) from ALB security group (sg-0f145c092dfa6267b) with Description=\"FromALB\"\n   - Rule 3: TCP Port 8080 from self-reference (security group ID) with Description=\"Loopback\"\n   - Use aws ec2 authorize-security-group-ingress for each rule\n\n3. Configure Outbound Rules:\n   - Rule 1: HTTP (80) to 0.0.0.0/0 (default outbound for package downloads)\n   - Rule 2: All TCP (0-65535) to ALB security group (sg-0f145c092dfa6267b) for health checks\n   - Rule 3: HTTPS (443) to 0.0.0.0/0 with Description=\"TODO\" (for external API calls)\n   - Rule 4: HTTPS (443) to VPC endpoints security group (from Task 9) for AWS service access\n   - Use aws ec2 authorize-security-group-egress for each rule\n\n4. Update CDK Code:\n   - Add security group creation in appropriate stack (likely TrialFinderV2Stack)\n   - Reference the security group in ECS task definitions\n   - Ensure proper imports for EC2 constructs\n   - Use CDK patterns for security group rules with descriptions",
        "testStrategy": "1. Verify Security Group Creation:\n   - Run aws ec2 describe-security-groups --filters \"Name=group-name,Values=dev-ecs-container-sg-ue2\" to confirm creation\n   - Validate all inbound rules are correctly configured with proper descriptions\n   - Check outbound rules match specifications\n   - Ensure security group is in the correct VPC\n\n2. Test Connectivity:\n   - Deploy a test ECS task using the new security group\n   - Verify ALB can reach containers on all ports (0-65535)\n   - Test container-to-container communication on port 8080\n   - Confirm containers can reach external HTTPS endpoints\n\n3. Integration Testing:\n   - Update ECS service to use new security group\n   - Monitor ECS service health checks through ALB\n   - Verify containers can access VPC endpoints for AWS services\n   - Check CloudWatch logs for any connectivity errors\n\n4. Security Validation:\n   - Use AWS Security Hub or Config to validate security group compliance\n   - Ensure the 0.0.0.0/0 rule is documented as temporary and tracked for removal\n   - Verify principle of least privilege is maintained for production use",
        "status": "pending",
        "dependencies": [
          3,
          8,
          9
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ECS container security group with ALB and self-reference inbound rules",
            "description": "Create a new security group for ECS containers that allows inbound traffic from the ALB security group and enables container-to-container communication through self-reference rules",
            "dependencies": [],
            "details": "Define security group in CDK with ingress rules allowing traffic from ALB security group on container port. Add self-referencing rule to allow containers within the same security group to communicate. Set appropriate tags and naming conventions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure outbound rules for internet and VPC endpoint access",
            "description": "Set up egress rules on the ECS container security group to allow outbound internet access and connectivity to VPC endpoints for AWS services",
            "dependencies": [
              1
            ],
            "details": "Add egress rules allowing HTTPS (443) traffic to the internet for downloading container images and accessing external services. Configure rules to allow connectivity to VPC endpoints (S3, ECR, CloudWatch) using appropriate security group references or CIDR blocks.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Update CDK ECS task definitions to use new security group",
            "description": "Modify the CDK code to assign the newly created security group to ECS task definitions and ensure proper integration with the service configuration",
            "dependencies": [
              1,
              2
            ],
            "details": "Update ECS task definition CDK constructs to reference the new container security group. Ensure the security group is properly passed to the ECS service configuration. Test deployment to verify containers can communicate with ALB and access required AWS services.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0",
      "created": "2025-01-12T00:21:00.000Z",
      "description": "Tasks for master context",
      "updated": "2025-07-12T19:55:48.231Z"
    }
  }
}